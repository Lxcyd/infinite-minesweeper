<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DÃ©mineur Infini</title>
<style>
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  background: #008080;
  font-family: 'Courier New', monospace;
}

#window {
  position: fixed;
  inset: 0;
  display: flex;
  flex-direction: column;
  background: #C0C0C0;
  border: 3px solid;
  border-color: #DFDFDF #404040 #404040 #DFDFDF;
  user-select: none;
}

#titlebar {
  flex: 0 0 auto;
  background: #000080;
  color: #fff;
  padding: 3px 8px;
  font-size: clamp(11px, 1.5vw, 14px);
  font-weight: bold;
  display: flex;
  align-items: center;
  gap: 6px;
  white-space: nowrap;
}
#titlebar-btns { margin-left: auto; display: flex; gap: 2px; }
.tb-btn {
  width: 18px; height: 16px;
  background: #C0C0C0;
  border: 1px solid;
  border-color: #DFDFDF #404040 #404040 #DFDFDF;
  font-size: 9px; cursor: pointer; color: #000;
  display: flex; align-items: center; justify-content: center;
}
.tb-btn:active { border-color: #404040 #DFDFDF #DFDFDF #404040; }

#header {
  flex: 0 0 auto;
  margin: 6px 6px 4px;
  padding: 4px 10px;
  border: 2px solid;
  border-color: #808080 #DFDFDF #DFDFDF #808080;
  display: flex; align-items: center; justify-content: space-between;
  gap: 8px;
  background: #C0C0C0;
}

.lcd-group { display: flex; flex-direction: column; align-items: center; gap: 2px; }

.lcd {
  background: #300; color: #FF2200;
  font-family: 'Courier New', monospace;
  font-size: clamp(16px, 2.8vw, 26px);
  font-weight: bold;
  padding: 2px 8px;
  min-width: clamp(52px, 8vw, 72px);
  text-align: right; letter-spacing: 3px;
  border: 2px solid;
  border-color: #404040 #DFDFDF #DFDFDF #404040;
  text-shadow: 0 0 5px #FF4400;
  white-space: nowrap;
}

.lcd-label {
  font-size: clamp(9px, 1.1vw, 11px);
  color: #333;
}

.center-controls { display: flex; flex-direction: column; align-items: center; gap: 3px; }

#face-btn {
  width: clamp(34px, 4.5vw, 48px);
  height: clamp(32px, 4vw, 44px);
  background: #C0C0C0;
  border: 3px solid;
  border-color: #DFDFDF #404040 #404040 #DFDFDF;
  cursor: pointer;
  font-size: clamp(16px, 2.5vw, 26px);
  display: flex; align-items: center; justify-content: center;
}
#face-btn:active { border-color: #404040 #DFDFDF #DFDFDF #404040; }

#undo-btn {
  width: clamp(34px, 4.5vw, 48px);
  height: clamp(18px, 2vw, 24px);
  background: #C0C0C0;
  border: 2px solid;
  border-color: #DFDFDF #404040 #404040 #DFDFDF;
  cursor: pointer;
  font-size: clamp(11px, 1.5vw, 15px);
  display: flex; align-items: center; justify-content: center;
}
#undo-btn:active { border-color: #404040 #DFDFDF #DFDFDF #404040; }

#canvas-wrap {
  flex: 1 1 0;
  margin: 0 6px 4px;
  border: 3px solid;
  border-color: #808080 #DFDFDF #DFDFDF #808080;
  overflow: hidden;
  position: relative;
  cursor: crosshair;
  min-height: 0;
}
#canvas { display: block; }
#canvas.panning { cursor: grab; }

#statusbar {
  flex: 0 0 auto;
  padding: 2px 8px;
  font-size: clamp(9px, 1.1vw, 11px);
  color: #444;
  display: flex; gap: 10px;
  border-top: 1px solid #808080;
  flex-wrap: wrap;
  white-space: nowrap;
}
#statusbar span {
  border-right: 1px solid #808080;
  padding-right: 8px;
}
#statusbar span:last-child { border-right: none; }

#gameover-banner {
  display: none;
  position: absolute; top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  background: #C0C0C0;
  border: 3px solid;
  border-color: #DFDFDF #404040 #404040 #DFDFDF;
  padding: 10px 20px;
  font-size: clamp(12px, 2vw, 16px);
  font-weight: bold; color: #CC0000;
  text-align: center; z-index: 10;
  box-shadow: 4px 4px 0 #000;
  white-space: nowrap;
}
</style>
</head>
<body>
<div id="window">

  <div id="titlebar">
    ðŸ’£ DÃ©mineur Infini
    <div id="titlebar-btns">
      <div class="tb-btn">_</div>
      <div class="tb-btn">â–¡</div>
      <div class="tb-btn">âœ•</div>
    </div>
  </div>

  <div id="header">
    <div class="lcd-group">
      <div class="lcd" id="flag-lcd">000</div>
      <div class="lcd-label">ðŸš© Drapeaux</div>
    </div>

    <div class="center-controls">
      <button id="face-btn" title="Nouveau jeu (Ctrl+R)">ðŸ™‚</button>
      <button id="undo-btn" title="Annuler (Ctrl+Z)">â†©</button>
    </div>

    <div class="lcd-group">
      <div class="lcd" id="undo-lcd">000</div>
      <div class="lcd-label">â†© Retours</div>
    </div>
  </div>

  <div id="canvas-wrap">
    <canvas id="canvas"></canvas>
    <div id="gameover-banner"></div>
  </div>

  <div id="statusbar">
    <span>Ctrl+Glisser : DÃ©placer</span>
    <span>Molette : Zoom</span>
    <span>ðŸ–± G : RÃ©vÃ©ler</span>
    <span>ðŸ–± D : Drapeau</span>
    <span>Ctrl+Z : Annuler</span>
    <span>Ctrl+R : Nouveau jeu</span>
  </div>

</div>
<script>
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// DOM
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas         = document.getElementById('canvas');
const ctx            = canvas.getContext('2d');
const flagLcd        = document.getElementById('flag-lcd');
const undoLcd        = document.getElementById('undo-lcd');
const faceBtnEl      = document.getElementById('face-btn');
const undoBtnEl      = document.getElementById('undo-btn');
const gameoverBanner = document.getElementById('gameover-banner');
const canvasWrap     = document.getElementById('canvas-wrap');

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Config
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const BASE_CELL       = 22;
const MINE_PCT        = 18;      // % of cells that are mines
const SAFE_RADIUS     = 4;       // guaranteed mine-free ring on first click
const MAX_FLOOD       = 20000;   // BFS limit to avoid freezing
const MAX_UNDO        = 80;
const ZOOM_MIN        = 0.18;
const ZOOM_MAX        = 4.5;

// Classic Win95 number colours
const NUM_COLORS = [
  null,
  '#0000CC', // 1 â€“ blue
  '#007700', // 2 â€“ green
  '#CC0000', // 3 â€“ red
  '#000077', // 4 â€“ dark blue
  '#880000', // 5 â€“ dark red
  '#007777', // 6 â€“ teal
  '#111111', // 7 â€“ black
  '#777777', // 8 â€“ grey
];

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Game state
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let revealed;    // Set<string>  â€“ keys of revealed cells
let flagged;     // Set<string>  â€“ keys of flagged cells
let safeCells;   // Set<string>  â€“ cells forced mine-free (first-click area)
let gameOver;    // bool
let dead;        // bool
let firstClick;  // bool â€“ is the very next reveal the first one?
let undoCount;   // number
let undoStack;   // Array of snapshots

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// View state
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let W = 0, H = 0;   // canvas pixel dimensions
let offX, offY;     // world â†’ screen offset (pixels)
let zoom;           // current zoom level

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Pan state
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let panning   = false;
let panX0, panY0, offX0, offY0;
let didPan    = false;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Deterministic infinite mine map
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Fast, decent 32-bit integer hash of a cell coordinate pair.
 * Different seeds are mixed in for X and Y to avoid symmetry artefacts.
 */
function hashXY(x, y) {
  let h = Math.imul(x | 0, 0x9e3779b9) ^ Math.imul(y | 0, 0x6c62272e);
  h ^= h >>> 16;
  h  = Math.imul(h, 0x45d9f3b);
  h ^= h >>> 16;
  return h >>> 0;
}

/**
 * Returns true when cell (x, y) contains a mine.
 * safeCells always overrides the hash (guaranteed safe on first click).
 */
function hasMine(x, y) {
  if (safeCells.has(K(x, y))) return false;
  return hashXY(x, y) % 100 < MINE_PCT;
}

/** Count mines in the 8 neighbours of (x, y). */
function countMines(x, y) {
  let n = 0;
  for (let dy = -1; dy <= 1; dy++)
    for (let dx = -1; dx <= 1; dx++)
      if (!(dx === 0 && dy === 0) && hasMine(x + dx, y + dy)) n++;
  return n;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Small helpers
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const K  = (x, y) => `${x},${y}`;
const cs = ()     => BASE_CELL * zoom;

function screenToCell(sx, sy) {
  const c = cs();
  return [Math.floor((sx - offX) / c), Math.floor((sy - offY) / c)];
}
function cellToScreen(cx, cy) {
  const c = cs();
  return [cx * c + offX, cy * c + offY];
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Undo system
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function snap() {
  undoStack.push({
    revealed:  new Set(revealed),
    flagged:   new Set(flagged),
    safeCells: new Set(safeCells),
    gameOver,
    dead,
    firstClick,
  });
  if (undoStack.length > MAX_UNDO) undoStack.shift();
}

function undo() {
  if (!undoStack.length) return;
  const s    = undoStack.pop();
  revealed   = s.revealed;
  flagged    = s.flagged;
  safeCells  = s.safeCells;
  gameOver   = s.gameOver;
  dead       = s.dead;
  firstClick = s.firstClick;
  undoCount++;
  if (!dead) setFace('normal');
  gameoverBanner.style.display = 'none';
  updateLCDs();
  render();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// First-click safe zone
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Mark a diamond-shaped (Chebyshev) region of radius SAFE_RADIUS around
 * (ox, oy) as mine-free.  This guarantees:
 *   â€¢ The clicked cell is safe.
 *   â€¢ All its 8 neighbours are safe  â†’ number = 0 â†’ flood fill starts.
 *   â€¢ A larger halo with radius SAFE_RADIUS ensures many more cells open up,
 *     just like the original Win95 Minesweeper.
 */
function buildSafeZone(ox, oy) {
  safeCells.clear();
  for (let dy = -SAFE_RADIUS; dy <= SAFE_RADIUS; dy++) {
    for (let dx = -SAFE_RADIUS; dx <= SAFE_RADIUS; dx++) {
      safeCells.add(K(ox + dx, oy + dy));
    }
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Core actions
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function reveal(x, y) {
  if (gameOver) return;
  const k = K(x, y);
  if (revealed.has(k) || flagged.has(k)) return;

  // â”€â”€ First click: carve a safe zone then proceed normally â”€â”€
  if (firstClick) {
    snap();           // undo point before any reveal
    buildSafeZone(x, y);
    firstClick = false;
    setFace('normal');
  } else {
    snap();
    setFace('normal');
  }

  // â”€â”€ Hit a mine â”€â”€
  if (hasMine(x, y)) {
    revealed.add(k);
    dead = gameOver = true;
    setFace('dead');
    showGameOver('ðŸ’¥ BOOM !   Appuie sur â†© pour revenir en arriÃ¨re');
    updateLCDs();
    render();
    return;
  }

  // â”€â”€ BFS flood fill â”€â”€
  const queue = [[x, y]];
  const seen  = new Set([k]);
  let   count = 0;

  while (queue.length && count < MAX_FLOOD) {
    const [cx, cy] = queue.shift();
    const ck = K(cx, cy);

    if (!revealed.has(ck)) {
      revealed.add(ck);
      count++;
    }

    // Propagate through empty cells (0 adjacent mines)
    if (countMines(cx, cy) === 0) {
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (!dx && !dy) continue;
          const nx = cx + dx, ny = cy + dy;
          const nk = K(nx, ny);
          if (!seen.has(nk) && !hasMine(nx, ny) && !flagged.has(nk)) {
            seen.add(nk);
            queue.push([nx, ny]);
          }
        }
      }
    }
  }

  updateLCDs();
  render();
}

function toggleFlag(x, y) {
  if (gameOver) return;
  const k = K(x, y);
  if (revealed.has(k)) return;
  snap();
  flagged.has(k) ? flagged.delete(k) : flagged.add(k);
  updateLCDs();
  render();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UI helpers
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setFace(f) {
  const map = { normal: 'ðŸ™‚', dead: 'ðŸ˜µ', scared: 'ðŸ˜®' };
  faceBtnEl.textContent = map[f] ?? 'ðŸ™‚';
}
function showGameOver(msg) {
  gameoverBanner.textContent    = msg;
  gameoverBanner.style.display  = 'block';
}
function updateLCDs() {
  flagLcd.textContent = String(Math.min(flagged.size, 999)).padStart(3, '0');
  undoLcd.textContent = String(Math.min(undoCount,   999)).padStart(3, '0');
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Rendering
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function render() {
  const c = cs();
  ctx.clearRect(0, 0, W, H);

  // Background between cells
  ctx.fillStyle = '#7b7b7b';
  ctx.fillRect(0, 0, W, H);

  // Visible cell range
  const x0 = Math.floor(-offX / c) - 1;
  const y0 = Math.floor(-offY / c) - 1;
  const x1 = Math.ceil((W - offX) / c) + 1;
  const y1 = Math.ceil((H - offY) / c) + 1;

  for (let cy = y0; cy <= y1; cy++)
    for (let cx = x0; cx <= x1; cx++)
      drawCell(cx, cy, c);
}

function drawCell(cx, cy, c) {
  const k = K(cx, cy);
  const [sx, sy] = cellToScreen(cx, cy);
  if (sx + c < 0 || sx > W || sy + c < 0 || sy > H) return;

  const isRev  = revealed.has(k);
  const isFl   = flagged.has(k);
  const isMine = hasMine(cx, cy);

  if (isRev) drawRevealedCell(sx, sy, c, isMine, isFl, cx, cy);
  else       drawHiddenCell(sx, sy, c, isFl, isMine);
}

// â”€â”€ Hidden (unrevealed) cell â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawHiddenCell(sx, sy, c, isFl, isMine) {
  const b = Math.max(1, c * 0.08);

  // Face
  ctx.fillStyle = '#C0C0C0';
  ctx.fillRect(sx, sy, c, c);

  // Top & left highlight
  ctx.fillStyle = '#FFFFFF';
  ctx.fillRect(sx,       sy,       c,  b);
  ctx.fillRect(sx,       sy,       b,  c);

  // Bottom & right outer shadow
  ctx.fillStyle = '#808080';
  ctx.fillRect(sx,       sy + c - b*2, c,  b);
  ctx.fillRect(sx + c - b*2, sy,       b,  c);

  // Bottom & right dark shadow
  ctx.fillStyle = '#404040';
  ctx.fillRect(sx,       sy + c - b,   c,  b);
  ctx.fillRect(sx + c - b,   sy,       b,  c);

  if (isFl) {
    drawFlag(sx, sy, c);
  } else if (gameOver && dead && isMine) {
    // Reveal un-triggered mines after death
    drawMine(sx, sy, c);
  }
}

// â”€â”€ Revealed cell â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawRevealedCell(sx, sy, c, isMine, isFl, cx, cy) {
  const b = Math.max(1, c * 0.04);

  // Background â€“ red if the fatal mine
  ctx.fillStyle = (isMine && dead) ? '#FF4444' : '#BEBEBE';
  ctx.fillRect(sx, sy, c, c);

  // Sunken border
  ctx.fillStyle = '#808080';
  ctx.fillRect(sx,       sy,       c,  b);
  ctx.fillRect(sx,       sy,       b,  c);
  ctx.fillStyle = '#DFDFDF';
  ctx.fillRect(sx,       sy + c - b, c,  b);
  ctx.fillRect(sx + c - b, sy,       b,  c);

  if (isMine) {
    drawMine(sx, sy, c);
  } else {
    const n = countMines(cx, cy);
    if (n > 0) {
      ctx.fillStyle    = NUM_COLORS[n] || '#000';
      const fs         = Math.max(8, Math.floor(c * 0.62));
      ctx.font         = `bold ${fs}px "Courier New"`;
      ctx.textAlign    = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(n, sx + c / 2, sy + c / 2 + 1);
    }
  }

  // Wrong flag marker (flagged non-mine â€“ shown after death)
  if (isFl && gameOver && !isMine) drawWrongFlag(sx, sy, c);
}

// â”€â”€ Flag â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawFlag(sx, sy, c) {
  const p   = c * 0.15;
  const mid = c / 2;
  const fw  = Math.max(1.5, c * 0.08);

  // Pole
  ctx.fillStyle = '#111';
  ctx.fillRect(sx + mid - fw / 2, sy + p, fw, c * 0.7);

  // Red triangular flag
  ctx.fillStyle = '#DD0000';
  ctx.beginPath();
  ctx.moveTo(sx + mid + fw / 2, sy + p + 1);
  ctx.lineTo(sx + c * 0.78,     sy + c * 0.35);
  ctx.lineTo(sx + mid + fw / 2, sy + c * 0.52);
  ctx.closePath();
  ctx.fill();

  // Base bar
  ctx.fillStyle = '#111';
  const bw = c * 0.45, bh = Math.max(1.5, c * 0.08);
  ctx.fillRect(sx + (c - bw) / 2, sy + c - p - bh, bw, bh);
}

// â”€â”€ Mine â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawMine(sx, sy, c) {
  const mx = sx + c / 2, my = sy + c / 2;
  const r  = c * 0.28;
  const lw = Math.max(1, r * 0.22);

  // Spikes
  ctx.strokeStyle = '#111';
  ctx.lineWidth   = lw;
  for (let i = 0; i < 8; i++) {
    const a = (i * Math.PI) / 4;
    ctx.beginPath();
    ctx.moveTo(mx + Math.cos(a) * r * 0.75, my + Math.sin(a) * r * 0.75);
    ctx.lineTo(mx + Math.cos(a) * r * 1.45, my + Math.sin(a) * r * 1.45);
    ctx.stroke();
  }

  // Body
  ctx.fillStyle = '#111';
  ctx.beginPath();
  ctx.arc(mx, my, r, 0, Math.PI * 2);
  ctx.fill();

  // Shine dot
  ctx.fillStyle = 'rgba(255,255,255,0.7)';
  ctx.beginPath();
  ctx.arc(mx - r * 0.28, my - r * 0.30, r * 0.18, 0, Math.PI * 2);
  ctx.fill();
}

// â”€â”€ Wrong-flag cross â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawWrongFlag(sx, sy, c) {
  const p  = c * 0.18;
  const lw = Math.max(2, c * 0.1);
  ctx.strokeStyle = '#FF0000';
  ctx.lineWidth   = lw;
  ctx.beginPath();
  ctx.moveTo(sx + p,     sy + p);     ctx.lineTo(sx + c - p, sy + c - p);
  ctx.moveTo(sx + c - p, sy + p);     ctx.lineTo(sx + p,     sy + c - p);
  ctx.stroke();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Responsive resize â€“ canvas fills its container
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function resize() {
  const rect = canvasWrap.getBoundingClientRect();
  const nw   = Math.floor(rect.width);
  const nh   = Math.floor(rect.height);
  if (nw === W && nh === H) return;

  // Keep the same visual centre after resize
  const fx = W ? offX / W : 0.5;
  const fy = H ? offY / H : 0.5;
  W = canvas.width  = nw;
  H = canvas.height = nh;
  offX = fx * W;
  offY = fy * H;
  render();
}

const ro = new ResizeObserver(resize);
ro.observe(canvasWrap);

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Reset / new game
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function reset() {
  revealed   = new Set();
  flagged    = new Set();
  safeCells  = new Set();
  gameOver   = false;
  dead       = false;
  firstClick = true;       // â† next reveal will create the safe zone
  undoCount  = 0;
  undoStack  = [];
  zoom       = 1.0;
  offX       = W / 2 - 6 * BASE_CELL;
  offY       = H / 2 - 6 * BASE_CELL;
  setFace('normal');
  gameoverBanner.style.display = 'none';
  updateLCDs();
  render();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Mouse events
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Pan start: Ctrl+left-drag  OR  middle-button drag
canvas.addEventListener('mousedown', e => {
  if (e.button === 1 || e.ctrlKey) {
    panning = true;
    didPan  = false;
    panX0   = e.clientX;
    panY0   = e.clientY;
    offX0   = offX;
    offY0   = offY;
    canvas.classList.add('panning');
    e.preventDefault();
  }
  if (e.button === 0 && !e.ctrlKey && !gameOver) setFace('scared');
});

canvas.addEventListener('mousemove', e => {
  if (!panning) return;
  const dx = e.clientX - panX0;
  const dy = e.clientY - panY0;
  if (Math.abs(dx) > 2 || Math.abs(dy) > 2) didPan = true;
  offX = offX0 + dx;
  offY = offY0 + dy;
  render();
});

const stopPan = () => { panning = false; canvas.classList.remove('panning'); };
canvas.addEventListener('mouseup', e => {
  stopPan();
  if (e.button === 0 && !dead) setFace('normal');
});
canvas.addEventListener('mouseleave', stopPan);

// Left click â†’ reveal
canvas.addEventListener('click', e => {
  if (didPan) { didPan = false; return; }
  if (e.ctrlKey) return;
  const rect       = canvas.getBoundingClientRect();
  const [cx, cy]   = screenToCell(e.clientX - rect.left, e.clientY - rect.top);
  reveal(cx, cy);
});

// Right click â†’ flag
canvas.addEventListener('contextmenu', e => {
  e.preventDefault();
  if (didPan) return;
  const rect     = canvas.getBoundingClientRect();
  const [cx, cy] = screenToCell(e.clientX - rect.left, e.clientY - rect.top);
  toggleFlag(cx, cy);
});

// Scroll wheel â†’ zoom (centred on cursor)
canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const rect   = canvas.getBoundingClientRect();
  const mx     = e.clientX - rect.left;
  const my     = e.clientY - rect.top;
  const factor = e.deltaY < 0 ? 1.13 : 1 / 1.13;
  const nz     = Math.min(ZOOM_MAX, Math.max(ZOOM_MIN, zoom * factor));
  const sc     = nz / zoom;
  offX         = mx - sc * (mx - offX);
  offY         = my - sc * (my - offY);
  zoom         = nz;
  render();
}, { passive: false });

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Touch events (mobile: 1-finger pan, 2-finger pinch-zoom, tap to reveal)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let lastTouchDist = null;
let lastTouchCx, lastTouchCy;

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  if (e.touches.length === 2) {
    lastTouchDist = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY,
    );
    lastTouchCx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
    lastTouchCy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
  } else if (e.touches.length === 1) {
    panning       = true;
    didPan        = false;
    panX0         = e.touches[0].clientX;
    panY0         = e.touches[0].clientY;
    offX0         = offX;
    offY0         = offY;
    lastTouchDist = null;
  }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  if (e.touches.length === 2 && lastTouchDist !== null) {
    const dist = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY,
    );
    const cx   = (e.touches[0].clientX + e.touches[1].clientX) / 2;
    const cy   = (e.touches[0].clientY + e.touches[1].clientY) / 2;
    const rect = canvas.getBoundingClientRect();
    const mx   = cx - rect.left;
    const my   = cy - rect.top;
    const nz   = Math.min(ZOOM_MAX, Math.max(ZOOM_MIN, zoom * (dist / lastTouchDist)));
    const sc   = nz / zoom;
    offX       = mx - sc * (mx - offX) + (cx - lastTouchCx);
    offY       = my - sc * (my - offY) + (cy - lastTouchCy);
    zoom       = nz;
    lastTouchDist = dist;
    lastTouchCx   = cx;
    lastTouchCy   = cy;
    render();
  } else if (e.touches.length === 1 && panning) {
    const dx = e.touches[0].clientX - panX0;
    const dy = e.touches[0].clientY - panY0;
    if (Math.abs(dx) > 2 || Math.abs(dy) > 2) didPan = true;
    offX = offX0 + dx;
    offY = offY0 + dy;
    render();
  }
}, { passive: false });

canvas.addEventListener('touchend', e => {
  e.preventDefault();
  // Single tap that didn't pan â†’ reveal
  if (e.changedTouches.length === 1 && !didPan && e.touches.length === 0) {
    const t    = e.changedTouches[0];
    const rect = canvas.getBoundingClientRect();
    const [cx, cy] = screenToCell(t.clientX - rect.left, t.clientY - rect.top);
    reveal(cx, cy);
  }
  panning       = false;
  didPan        = false;
  lastTouchDist = null;
}, { passive: false });

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Keyboard
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.addEventListener('keydown', e => {
  if (e.ctrlKey && e.key === 'z') { e.preventDefault(); undo();  }
  if (e.ctrlKey && e.key === 'r') { e.preventDefault(); reset(); }
});

faceBtnEl.addEventListener('click', reset);
undoBtnEl.addEventListener('click', undo);

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Boot â€“ wait one animation frame so the layout is settled, then initialise
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
requestAnimationFrame(() => {
  const rect  = canvasWrap.getBoundingClientRect();
  W           = canvas.width  = Math.floor(rect.width);
  H           = canvas.height = Math.floor(rect.height);
  revealed    = new Set();
  flagged     = new Set();
  safeCells   = new Set();
  gameOver    = false;
  dead        = false;
  firstClick  = true;
  undoCount   = 0;
  undoStack   = [];
  zoom        = 1.0;
  offX        = W / 2 - 6 * BASE_CELL;
  offY        = H / 2 - 6 * BASE_CELL;
  updateLCDs();
  render();
});
</script>
</body>
</html>
