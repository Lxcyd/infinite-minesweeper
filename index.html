<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>‚àû D√©mineur Infini</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Sora:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;600&display=swap');

*, *::before, *::after {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

:root {
  --bg-main: #080c18;
  --bg-panel: rgba(14, 18, 32, 0.85);
  --bg-card: rgba(22, 28, 46, 0.9);
  --accent-primary: #00d4ff;
  --accent-secondary: #ff2d6b;
  --accent-success: #00ffaa;
  --accent-warning: #ffaa00;
  --text-primary: #f0f4ff;
  --text-secondary: #7888a8;
  --border-color: rgba(255, 255, 255, 0.08);
  --border-hover: rgba(0, 212, 255, 0.35);
  --shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
  --glow: 0 0 24px rgba(0, 212, 255, 0.25);
  --sidebar-width: 320px;
}

html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: var(--bg-main);
  font-family: 'Sora', sans-serif;
  color: var(--text-primary);
}

#bg-canvas {
  position: fixed;
  inset: 0;
  z-index: 0;
  opacity: 0.25;
}

#app {
  position: fixed;
  inset: 0;
  display: flex;
  flex-direction: column;
  z-index: 1;
}

/* ‚îÄ‚îÄ‚îÄ HEADER ‚îÄ‚îÄ‚îÄ */
#header {
  flex: 0 0 auto;
  backdrop-filter: blur(24px);
  background: var(--bg-panel);
  border-bottom: 1px solid var(--border-color);
  padding: 14px 24px;
  display: flex;
  align-items: center;
  gap: 20px;
  box-shadow: var(--shadow);
  z-index: 10;
}

#logo {
  display: flex;
  align-items: center;
  gap: 12px;
  font-size: 18px;
  font-weight: 700;
  letter-spacing: -0.5px;
  white-space: nowrap;
}

#logo-icon {
  width: 34px;
  height: 34px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, rgba(0,212,255,0.15), rgba(255,45,107,0.15));
  border: 1px solid rgba(0,212,255,0.3);
  border-radius: 10px;
  flex-shrink: 0;
}

#logo-icon svg {
  filter: drop-shadow(0 0 6px rgba(0,212,255,0.7));
}

.header-stats {
  display: flex;
  gap: 12px;
  margin-left: auto;
}

.stat-card {
  backdrop-filter: blur(10px);
  background: var(--bg-card);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 8px 16px;
  display: flex;
  flex-direction: column;
  gap: 2px;
  min-width: 90px;
  transition: border-color 0.3s, transform 0.2s;
}

.stat-card:hover {
  transform: translateY(-2px);
  border-color: var(--border-hover);
}

.stat-label {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.8px;
  color: var(--text-secondary);
}

.stat-value {
  font-family: 'JetBrains Mono', monospace;
  font-size: 22px;
  font-weight: 600;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.btn-group {
  display: flex;
  gap: 8px;
}

.btn {
  backdrop-filter: blur(10px);
  background: var(--bg-card);
  border: 1px solid var(--border-color);
  border-radius: 10px;
  padding: 9px 16px;
  font-family: 'Sora', sans-serif;
  font-size: 13px;
  font-weight: 600;
  color: var(--text-primary);
  cursor: pointer;
  transition: background 0.2s, border-color 0.2s, transform 0.15s, box-shadow 0.2s;
  display: flex;
  align-items: center;
  gap: 7px;
  white-space: nowrap;
}

.btn:hover {
  background: rgba(40, 48, 72, 0.95);
  border-color: var(--border-hover);
  transform: translateY(-1px);
  box-shadow: 0 4px 16px rgba(0, 212, 255, 0.15);
}

.btn:active { transform: translateY(0); }

.btn-primary {
  background: linear-gradient(135deg, #00b8d9, #0086b3);
  border: none;
  box-shadow: 0 4px 16px rgba(0, 212, 255, 0.3);
  color: #fff;
}

.btn-primary:hover {
  box-shadow: 0 6px 22px rgba(0, 212, 255, 0.45);
  transform: translateY(-2px);
  background: linear-gradient(135deg, #00d4ff, #0099cc);
}

.btn-icon {
  font-size: 15px;
  line-height: 1;
}

/* ‚îÄ‚îÄ‚îÄ GAME AREA ‚îÄ‚îÄ‚îÄ */
#game-container {
  flex: 1 1 0;
  display: flex;
  min-height: 0;
  position: relative;
  overflow: hidden;
}

#canvas-wrap {
  flex: 1 1 0;
  position: relative;
  overflow: hidden;
  cursor: crosshair;
}

#canvas {
  display: block;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
}

#canvas.panning {
  cursor: grab;
}

/* ‚îÄ‚îÄ‚îÄ SIDEBAR TOGGLE (floating) ‚îÄ‚îÄ‚îÄ */
#sidebar-float-toggle {
  position: absolute;
  right: 0;
  top: 50%;
  transform: translateY(-50%);
  z-index: 30;
  width: 28px;
  height: 64px;
  background: var(--bg-card);
  border: 1px solid var(--border-color);
  border-right: none;
  border-radius: 10px 0 0 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: background 0.2s, border-color 0.2s, box-shadow 0.2s;
  font-size: 13px;
  color: var(--text-secondary);
}

#sidebar-float-toggle:hover {
  background: rgba(40, 48, 72, 0.95);
  border-color: var(--border-hover);
  color: var(--accent-primary);
  box-shadow: -4px 0 16px rgba(0,212,255,0.1);
}

#sidebar-float-toggle.hidden-mode {
  right: calc(var(--sidebar-width));
  transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1),
              background 0.2s, border-color 0.2s;
}

/* ‚îÄ‚îÄ‚îÄ SIDEBAR ‚îÄ‚îÄ‚îÄ */
#sidebar {
  width: var(--sidebar-width);
  backdrop-filter: blur(24px);
  background: var(--bg-panel);
  border-left: 1px solid var(--border-color);
  padding: 20px 20px 20px;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 16px;
  flex-shrink: 0;
  /* Slide in/out */
  transform: translateX(0);
  transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1),
              box-shadow 0.4s ease;
  will-change: transform;
  box-shadow: -8px 0 32px rgba(0,0,0,0.3);
  position: relative;
  z-index: 20;
}

#sidebar.collapsed {
  transform: translateX(100%);
  box-shadow: none;
}

#sidebar-close-btn {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 4px;
}

#sidebar-close-btn .panel-label {
  font-size: 11px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: var(--text-secondary);
}

#sidebar-x-btn {
  width: 30px;
  height: 30px;
  background: rgba(255,45,107,0.1);
  border: 1px solid rgba(255,45,107,0.25);
  border-radius: 8px;
  color: var(--accent-secondary);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  transition: background 0.2s, border-color 0.2s, transform 0.15s;
}

#sidebar-x-btn:hover {
  background: rgba(255,45,107,0.2);
  border-color: rgba(255,45,107,0.5);
  transform: scale(1.1);
}

.panel {
  background: var(--bg-card);
  border: 1px solid var(--border-color);
  border-radius: 14px;
  padding: 18px;
  transition: border-color 0.2s;
}

.panel:hover {
  border-color: rgba(255,255,255,0.12);
}

.panel-title {
  font-size: 12px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.8px;
  color: var(--text-secondary);
  margin-bottom: 14px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.panel-icon { font-size: 15px; }

.input-group {
  display: flex;
  flex-direction: column;
  gap: 7px;
  margin-bottom: 12px;
}

.input-group label {
  font-size: 12px;
  font-weight: 500;
  color: var(--text-secondary);
}

.input-group input {
  background: rgba(8, 12, 24, 0.7);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 9px 12px;
  font-family: 'JetBrains Mono', monospace;
  font-size: 13px;
  color: var(--text-primary);
  transition: border-color 0.2s, box-shadow 0.2s;
  width: 100%;
}

.input-group input:focus {
  outline: none;
  border-color: var(--accent-primary);
  box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.1);
}

.input-group input::placeholder {
  color: var(--text-secondary);
  opacity: 0.4;
}

.btn-small {
  padding: 8px 14px;
  font-size: 12px;
}

.help-text {
  font-size: 12px;
  color: var(--text-secondary);
  line-height: 1.6;
  margin-top: 8px;
}

.shortcut-list {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.shortcut-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 7px 10px;
  background: rgba(8, 12, 24, 0.4);
  border-radius: 7px;
  font-size: 12px;
  color: var(--text-secondary);
}

.shortcut-item span:first-child { color: var(--text-primary); }

.shortcut-key {
  background: rgba(255, 255, 255, 0.07);
  border: 1px solid rgba(255,255,255,0.12);
  padding: 3px 7px;
  border-radius: 5px;
  font-family: 'JetBrains Mono', monospace;
  font-size: 10px;
  font-weight: 600;
  color: var(--accent-primary);
  white-space: nowrap;
}

.tip-box {
  font-size: 12px;
  color: var(--text-secondary);
  line-height: 1.6;
  padding: 14px;
  background: rgba(0, 212, 255, 0.05);
  border-radius: 10px;
  border: 1px solid rgba(0, 212, 255, 0.15);
}

.tip-box strong { color: var(--accent-primary); }

/* ‚îÄ‚îÄ‚îÄ MOBILE CONTROLS ‚îÄ‚îÄ‚îÄ */
#mobile-controls {
  display: none;
  position: fixed;
  bottom: 24px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 50;
  gap: 16px;
}

.mobile-mode-btn {
  width: 68px;
  height: 68px;
  backdrop-filter: blur(20px);
  background: var(--bg-card);
  border: 2px solid var(--border-color);
  border-radius: 50%;
  font-size: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.25s ease;
  box-shadow: 0 8px 28px rgba(0, 0, 0, 0.4);
}

.mobile-mode-btn:active { transform: scale(0.93); }

.mobile-mode-btn.active {
  border-color: var(--accent-primary);
  background: rgba(0, 212, 255, 0.15);
  box-shadow: 0 0 24px rgba(0, 212, 255, 0.4);
}

/* ‚îÄ‚îÄ‚îÄ MODAL ‚îÄ‚îÄ‚îÄ */
#modal-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.75);
  backdrop-filter: blur(10px);
  z-index: 100;
  align-items: center;
  justify-content: center;
  animation: fadeIn 0.25s ease;
}

#modal-overlay.show { display: flex; }

.modal {
  backdrop-filter: blur(24px);
  background: var(--bg-card);
  border: 1px solid var(--border-color);
  border-radius: 22px;
  padding: 44px 40px 40px;
  max-width: 480px;
  width: 90%;
  text-align: center;
  box-shadow: 0 24px 64px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(255,255,255,0.05);
  animation: slideUp 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.modal-icon { font-size: 64px; margin-bottom: 18px; }

.modal-title {
  font-size: 28px;
  font-weight: 700;
  margin-bottom: 10px;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.modal-text {
  font-size: 15px;
  color: var(--text-secondary);
  margin-bottom: 28px;
  line-height: 1.6;
}

.modal-actions {
  display: flex;
  gap: 12px;
  justify-content: center;
  flex-wrap: wrap;
}

/* ‚îÄ‚îÄ‚îÄ TOAST ‚îÄ‚îÄ‚îÄ */
#toast-container {
  position: fixed;
  top: 76px;
  right: 24px;
  z-index: 200;
  display: flex;
  flex-direction: column;
  gap: 10px;
  pointer-events: none;
}

.toast {
  backdrop-filter: blur(20px);
  background: var(--bg-card);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 14px 18px;
  display: flex;
  align-items: center;
  gap: 12px;
  box-shadow: var(--shadow);
  animation: slideInRight 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
  pointer-events: all;
  min-width: 260px;
}

.toast-icon { font-size: 20px; }
.toast-title { font-size: 13px; font-weight: 600; margin-bottom: 2px; }
.toast-message { font-size: 11px; color: var(--text-secondary); }
.toast.success { border-left: 3px solid var(--accent-success); }
.toast.error { border-left: 3px solid var(--accent-secondary); }
.toast.info { border-left: 3px solid var(--accent-primary); }

@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

@keyframes slideUp {
  from { opacity: 0; transform: translateY(24px) scale(0.96); }
  to { opacity: 1; transform: translateY(0) scale(1); }
}

@keyframes slideInRight {
  from { opacity: 0; transform: translateX(100%); }
  to { opacity: 1; transform: translateX(0); }
}

@media (max-width: 768px) {
  #header { flex-wrap: wrap; padding: 10px 14px; gap: 10px; }
  .header-stats { order: 3; width: 100%; justify-content: space-between; }
  .stat-card { min-width: auto; flex: 1; }
  #sidebar {
    position: fixed;
    right: 0;
    top: 0;
    height: 100%;
    z-index: 50;
  }
  #sidebar.collapsed { transform: translateX(100%); }
  .btn-group { flex-wrap: wrap; }
  #mobile-controls { display: flex; }
  #toast-container { right: 12px; left: 12px; }
  .toast { min-width: auto; }
  #sidebar-float-toggle { display: none; }
}

::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.12); border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.2); }
</style>
</head>
<body>

<canvas id="bg-canvas"></canvas>
<div id="toast-container"></div>

<div id="modal-overlay">
  <div class="modal">
    <div class="modal-icon" id="modal-icon">üí•</div>
    <div class="modal-title" id="modal-title">Boom!</div>
    <div class="modal-text" id="modal-text">Vous avez touch√© une mine</div>
    <div class="modal-actions" id="modal-actions">
      <button class="btn btn-primary" id="modal-confirm">
        <span class="btn-icon">‚úì</span> Confirmer
      </button>
      <button class="btn" id="modal-cancel">
        <span class="btn-icon">‚úï</span> Annuler
      </button>
    </div>
  </div>
</div>

<div id="app">
  <div id="header">
    <div id="logo">
      <div id="logo-icon">
        <!-- Modern SVG infinity icon -->
        <svg width="22" height="14" viewBox="0 0 22 14" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M8 7C8 7 6.5 3 4 3C1.8 3 0 4.8 0 7C0 9.2 1.8 11 4 11C6.5 11 8 7 8 7Z" fill="none" stroke="#00d4ff" stroke-width="2" stroke-linecap="round"/>
          <path d="M14 7C14 7 15.5 3 18 3C20.2 3 22 4.8 22 7C22 9.2 20.2 11 18 11C15.5 11 14 7 14 7Z" fill="none" stroke="#00d4ff" stroke-width="2" stroke-linecap="round"/>
          <path d="M8 7C8 7 9.5 11 11 11C12.5 11 14 7 14 7C14 7 12.5 3 11 3C9.5 3 8 7 8 7Z" fill="none" stroke="#ff2d6b" stroke-width="2" stroke-linecap="round"/>
        </svg>
      </div>
      <span>D√©mineur Infini</span>
    </div>

    <div class="btn-group">
      <button class="btn btn-primary" id="new-game-btn" title="Ctrl+R">
        <span class="btn-icon">‚ü≥</span> Nouveau
      </button>
      <button class="btn" id="undo-btn" title="Ctrl+Z">
        <span class="btn-icon">‚Ü©</span> Annuler
      </button>
      <button class="btn" id="save-btn" title="Ctrl+S">
        <span class="btn-icon">‚¨°</span> Sauvegarder
      </button>
      <button class="btn" id="export-btn" title="Exporter">
        <span class="btn-icon">‚¨Ü</span> Export
      </button>
      <button class="btn" id="sidebar-toggle-mobile" title="Menu">
        <span class="btn-icon">‚öô</span>
      </button>
    </div>

    <div class="header-stats">
      <div class="stat-card">
        <div class="stat-label">üö© Drapeaux</div>
        <div class="stat-value" id="flag-count">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">‚Ü© Retours</div>
        <div class="stat-value" id="undo-count">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">‚óà Cases</div>
        <div class="stat-value" id="revealed-count">0</div>
      </div>
    </div>
  </div>

  <div id="game-container">
    <div id="canvas-wrap">
      <canvas id="canvas"></canvas>
      <!-- Floating sidebar toggle -->
      <div id="sidebar-float-toggle" title="Ouvrir/Fermer le panneau">‚Ä∫</div>
    </div>

    <div id="mobile-controls">
      <button class="mobile-mode-btn active" id="mobile-reveal" title="Mode r√©v√©lation">üí°</button>
      <button class="mobile-mode-btn" id="mobile-flag" title="Mode drapeau">üö©</button>
    </div>

    <div id="sidebar">
      <div id="sidebar-close-btn">
        <span class="panel-label">Panneau</span>
        <button id="sidebar-x-btn" title="Fermer">‚úï</button>
      </div>

      <div class="panel">
        <div class="panel-title">
          <span class="panel-icon">üé≤</span>
          <span>Seed & G√©n√©ration</span>
        </div>
        <div class="input-group">
          <label for="seed-input">Seed (vide = al√©atoire)</label>
          <input type="text" id="seed-input" placeholder="Ex: minecraft123">
        </div>
        <button class="btn btn-small" id="apply-seed-btn" style="width:100%;">
          <span class="btn-icon">‚ú®</span> Appliquer seed
        </button>
        <div class="help-text">La seed g√©n√®re toujours la m√™me carte. Partagez-la !</div>
        <div class="input-group" style="margin-top:14px;">
          <label>Seed actuelle</label>
          <input type="text" id="current-seed" readonly style="opacity:0.6;">
        </div>
      </div>

      <div class="panel">
        <div class="panel-title">
          <span class="panel-icon">üíæ</span>
          <span>Import / Export</span>
        </div>
        <div class="input-group">
          <label for="import-input">Coller un code de partie</label>
          <input type="text" id="import-input" placeholder="Collez le code ici...">
        </div>
        <button class="btn btn-small" id="import-btn" style="width:100%;">
          <span class="btn-icon">‚Üì</span> Importer partie
        </button>
        <div class="help-text">Le code contient la seed, les cases r√©v√©l√©es et les drapeaux.</div>
      </div>

      <div class="panel">
        <div class="panel-title">
          <span class="panel-icon">‚å®</span>
          <span>Raccourcis</span>
        </div>
        <div class="shortcut-list">
          <div class="shortcut-item"><span>R√©v√©ler case</span><span class="shortcut-key">Clic gauche</span></div>
          <div class="shortcut-item"><span>Placer drapeau</span><span class="shortcut-key">Clic droit</span></div>
          <div class="shortcut-item"><span>Chord (auto)</span><span class="shortcut-key">Clic sur num√©ro</span></div>
          <div class="shortcut-item"><span>D√©placer vue</span><span class="shortcut-key">Ctrl + Glisser</span></div>
          <div class="shortcut-item"><span>Zoom</span><span class="shortcut-key">Molette</span></div>
          <div class="shortcut-item"><span>Annuler</span><span class="shortcut-key">Ctrl+Z</span></div>
          <div class="shortcut-item"><span>Nouveau jeu</span><span class="shortcut-key">Ctrl+R</span></div>
          <div class="shortcut-item"><span>Sauvegarder</span><span class="shortcut-key">Ctrl+S</span></div>
        </div>
      </div>

      <div class="tip-box">
        üí° <strong>Astuce Chord :</strong> Quand un num√©ro est r√©v√©l√© avec le bon nombre de drapeaux autour, cliquez dessus pour r√©v√©ler automatiquement toutes les cases s√ªres adjacentes !
      </div>
    </div>
  </div>
</div>

<script>
const CONFIG = {
  BASE_CELL: 24,
  MINE_PCT: 18,
  SAFE_RADIUS: 4,
  MAX_FLOOD: 30000,
  MAX_UNDO: 100,
  ZOOM_MIN: 0.15,
  ZOOM_MAX: 5,
  ZOOM_TEXTURE_THRESHOLD: 0.4,
  AUTO_SAVE_INTERVAL: 10000,
  RENDER_CULLING: 2,
};

const COLORS = {
  numbers: [null, '#4fc3f7', '#81c784', '#e57373', '#ba68c8', '#ffb74d', '#26c6da', '#a1887f', '#90a4ae'],
  cell: {
    revealed: '#1a2035',
    hidden: '#2d3655',
    hiddenHover: '#3a4470',
    border: '#0d1120',
    borderLight: '#4a5280',
  },
  mine: '#ff2d6b',
  flag: '#ffaa00',
};

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
const bgCanvas = document.getElementById('bg-canvas');
const bgCtx = bgCanvas.getContext('2d');

const flagCountEl = document.getElementById('flag-count');
const undoCountEl = document.getElementById('undo-count');
const revealedCountEl = document.getElementById('revealed-count');
const currentSeedEl = document.getElementById('current-seed');
const seedInputEl = document.getElementById('seed-input');
const importInputEl = document.getElementById('import-input');

const newGameBtn = document.getElementById('new-game-btn');
const undoBtn = document.getElementById('undo-btn');
const saveBtn = document.getElementById('save-btn');
const exportBtn = document.getElementById('export-btn');
const applySeedBtn = document.getElementById('apply-seed-btn');
const importBtn = document.getElementById('import-btn');
const sidebarToggleMobile = document.getElementById('sidebar-toggle-mobile');
const sidebarXBtn = document.getElementById('sidebar-x-btn');
const sidebarFloatToggle = document.getElementById('sidebar-float-toggle');

const sidebar = document.getElementById('sidebar');
const modalOverlay = document.getElementById('modal-overlay');
const modalIcon = document.getElementById('modal-icon');
const modalTitle = document.getElementById('modal-title');
const modalText = document.getElementById('modal-text');
const modalActions = document.getElementById('modal-actions');
const modalConfirm = document.getElementById('modal-confirm');
const modalCancel = document.getElementById('modal-cancel');
const mobileRevealBtn = document.getElementById('mobile-reveal');
const mobileFlagBtn = document.getElementById('mobile-flag');
const canvasWrap = document.getElementById('canvas-wrap');
const toastContainer = document.getElementById('toast-container');

let sidebarOpen = true;

function toggleSidebar(forceState) {
  if (forceState !== undefined) {
    sidebarOpen = forceState;
  } else {
    sidebarOpen = !sidebarOpen;
  }
  sidebar.classList.toggle('collapsed', !sidebarOpen);
  sidebarFloatToggle.textContent = sidebarOpen ? '‚Ä∫' : '‚Äπ';
  sidebarFloatToggle.style.right = sidebarOpen ? '' : '0';
  // Trigger resize after transition
  setTimeout(() => { resize(); }, 420);
}

sidebarXBtn.addEventListener('click', () => toggleSidebar(false));
sidebarFloatToggle.addEventListener('click', () => toggleSidebar());
sidebarToggleMobile.addEventListener('click', () => {
  if (window.innerWidth <= 768) {
    sidebar.classList.toggle('show');
  } else {
    toggleSidebar();
  }
});

let gameState = {
  seed: '',
  rng: null,
  revealed: new Set(),
  flagged: new Set(),
  safeCells: new Set(),
  gameOver: false,
  dead: false,
  firstClick: true,
  mineHit: null,
  undoCount: 0,
  undoStack: [],
  revealedCount: 0,
  mobileMode: 'reveal',
};

let viewState = {
  W: 0, H: 0,
  offX: 0, offY: 0,
  zoom: 1.0,
  panning: false,
  panStartX: 0, panStartY: 0,
  panOffX0: 0, panOffY0: 0,
  didPan: false,
  hoverCell: null,
  dirtyRender: true,
  hiddenTexture: null,
};

class SeededRandom {
  constructor(seed) {
    this.state = this.hashString(seed);
  }
  hashString(str) {
    let h = 0;
    for (let i = 0; i < str.length; i++) {
      h = Math.imul(31, h) + str.charCodeAt(i) | 0;
    }
    return h >>> 0;
  }
  next() {
    let t = this.state += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
  hashXY(x, y) {
    let h = Math.imul(x | 0, 0x9e3779b9) ^ Math.imul(y | 0, 0x6c62272e);
    h ^= this.state;
    h ^= h >>> 16;
    h = Math.imul(h, 0x45d9f3b);
    h ^= h >>> 16;
    return (h >>> 0) % 100;
  }
}

function hasMine(x, y) {
  // Guard: if rng not ready, no mines
  if (!gameState.rng) return false;
  const k = key(x, y);
  if (gameState.safeCells.has(k)) return false;
  return gameState.rng.hashXY(x, y) < CONFIG.MINE_PCT;
}

function countMines(x, y) {
  let count = 0;
  for (let dy = -1; dy <= 1; dy++)
    for (let dx = -1; dx <= 1; dx++)
      if (dx !== 0 || dy !== 0)
        if (hasMine(x + dx, y + dy)) count++;
  return count;
}

const key = (x, y) => `${x},${y}`;
const cellSize = () => CONFIG.BASE_CELL * viewState.zoom;

function screenToCell(sx, sy) {
  const c = cellSize();
  return [Math.floor((sx - viewState.offX) / c), Math.floor((sy - viewState.offY) / c)];
}

function cellToScreen(cx, cy) {
  const c = cellSize();
  return [cx * c + viewState.offX, cy * c + viewState.offY];
}

function generateRandomSeed() {
  const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
  let seed = '';
  for (let i = 0; i < 12; i++) seed += chars[Math.floor(Math.random() * chars.length)];
  return seed;
}

function snapshot() {
  gameState.undoStack.push({
    revealed: new Set(gameState.revealed),
    flagged: new Set(gameState.flagged),
    safeCells: new Set(gameState.safeCells),
    gameOver: gameState.gameOver,
    dead: gameState.dead,
    firstClick: gameState.firstClick,
    mineHit: gameState.mineHit,
    revealedCount: gameState.revealedCount,
  });
  if (gameState.undoStack.length > CONFIG.MAX_UNDO) gameState.undoStack.shift();
}

function undo() {
  if (gameState.undoStack.length === 0) { showToast('info', 'Impossible d\'annuler', 'Aucune action √† annuler'); return; }
  const snap = gameState.undoStack.pop();
  gameState.revealed = snap.revealed;
  gameState.flagged = snap.flagged;
  gameState.safeCells = snap.safeCells;
  gameState.gameOver = snap.gameOver;
  gameState.dead = snap.dead;
  gameState.firstClick = snap.firstClick;
  gameState.mineHit = snap.mineHit;
  gameState.revealedCount = snap.revealedCount;
  gameState.undoCount++;
  if (gameState.gameOver) modalOverlay.classList.remove('show');
  updateUI();
  viewState.dirtyRender = true;
  requestRender();
  showToast('success', 'Action annul√©e', 'Retour en arri√®re effectu√©');
}

function buildSafeZone(ox, oy) {
  gameState.safeCells.clear();
  for (let dy = -CONFIG.SAFE_RADIUS; dy <= CONFIG.SAFE_RADIUS; dy++)
    for (let dx = -CONFIG.SAFE_RADIUS; dx <= CONFIG.SAFE_RADIUS; dx++)
      gameState.safeCells.add(key(ox + dx, oy + dy));
}

function reveal(x, y) {
  if (gameState.gameOver) return;
  const k = key(x, y);
  if (gameState.revealed.has(k)) { chord(x, y); return; }
  if (gameState.flagged.has(k)) return;

  if (gameState.firstClick) { snapshot(); buildSafeZone(x, y); gameState.firstClick = false; }
  else snapshot();

  if (hasMine(x, y)) {
    gameState.revealed.add(k);
    gameState.revealedCount++;
    gameState.dead = true;
    gameState.gameOver = true;
    gameState.mineHit = [x, y];
    showGameOverModal();
    updateUI();
    viewState.dirtyRender = true;
    requestRender();
    return;
  }

  const queue = [[x, y]];
  const seen = new Set([k]);
  let count = 0;

  while (queue.length > 0 && count < CONFIG.MAX_FLOOD) {
    const [cx, cy] = queue.shift();
    const ck = key(cx, cy);
    if (!gameState.revealed.has(ck)) { gameState.revealed.add(ck); gameState.revealedCount++; count++; }
    const mineCount = countMines(cx, cy);
    if (mineCount === 0) {
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = cx + dx, ny = cy + dy, nk = key(nx, ny);
          if (!seen.has(nk) && !hasMine(nx, ny) && !gameState.flagged.has(nk)) { seen.add(nk); queue.push([nx, ny]); }
        }
      }
    }
  }
  updateUI();
  viewState.dirtyRender = true;
  requestRender();
}

function chord(x, y) {
  const k = key(x, y);
  if (!gameState.revealed.has(k) || hasMine(x, y)) return;
  const mineCount = countMines(x, y);
  if (mineCount === 0) return;
  let flagCount = 0;
  for (let dy = -1; dy <= 1; dy++)
    for (let dx = -1; dx <= 1; dx++)
      if ((dx !== 0 || dy !== 0) && gameState.flagged.has(key(x + dx, y + dy))) flagCount++;
  if (flagCount === mineCount) {
    snapshot();
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue;
        const nx = x + dx, ny = y + dy, nk = key(nx, ny);
        if (!gameState.revealed.has(nk) && !gameState.flagged.has(nk)) reveal(nx, ny);
      }
    }
  }
}

function toggleFlag(x, y) {
  if (gameState.gameOver) return;
  const k = key(x, y);
  if (gameState.revealed.has(k)) return;
  snapshot();
  if (gameState.flagged.has(k)) gameState.flagged.delete(k);
  else gameState.flagged.add(k);
  updateUI();
  viewState.dirtyRender = true;
  requestRender();
}

let renderQueued = false;
function requestRender() {
  if (!renderQueued) {
    renderQueued = true;
    requestAnimationFrame(() => { render(); renderQueued = false; });
  }
}

function render() {
  if (!viewState.dirtyRender) return;
  const c = cellSize();
  const { W, H, offX, offY } = viewState;

  ctx.fillStyle = COLORS.cell.border;
  ctx.fillRect(0, 0, W, H);

  const margin = CONFIG.RENDER_CULLING;
  const x0 = Math.floor(-offX / c) - margin;
  const y0 = Math.floor(-offY / c) - margin;
  const x1 = Math.ceil((W - offX) / c) + margin;
  const y1 = Math.ceil((H - offY) / c) + margin;

  const useTexture = viewState.zoom < CONFIG.ZOOM_TEXTURE_THRESHOLD;

  if (useTexture) {
    ctx.fillStyle = COLORS.cell.hidden;
    ctx.fillRect(0, 0, W, H);
    for (let cy = y0; cy <= y1; cy++)
      for (let cx = x0; cx <= x1; cx++) {
        const k = key(cx, cy);
        if (gameState.revealed.has(k) || gameState.flagged.has(k)) drawCell(cx, cy, c);
      }
  } else {
    for (let cy = y0; cy <= y1; cy++)
      for (let cx = x0; cx <= x1; cx++) drawCell(cx, cy, c);
  }

  if (viewState.hoverCell && !gameState.gameOver && !useTexture) {
    const [hx, hy] = viewState.hoverCell;
    const [sx, sy] = cellToScreen(hx, hy);
    ctx.strokeStyle = 'rgba(0, 212, 255, 0.45)';
    ctx.lineWidth = Math.max(2, c * 0.07);
    ctx.strokeRect(sx + 1, sy + 1, c - 2, c - 2);
  }

  viewState.dirtyRender = false;
}

function drawCell(cx, cy, c) {
  const k = key(cx, cy);
  const [sx, sy] = cellToScreen(cx, cy);
  if (sx + c < 0 || sx > viewState.W || sy + c < 0 || sy > viewState.H) return;

  const isRevealed = gameState.revealed.has(k);
  const isFlagged = gameState.flagged.has(k);
  const isMine = hasMine(cx, cy);
  const isHitMine = gameState.mineHit && gameState.mineHit[0] === cx && gameState.mineHit[1] === cy;

  if (isRevealed) drawRevealedCell(sx, sy, c, isMine, isHitMine, cx, cy);
  else drawHiddenCell(sx, sy, c, isFlagged);
}

function drawHiddenCell(sx, sy, c, isFlagged) {
  const pad = Math.max(1, c * 0.04);
  ctx.fillStyle = COLORS.cell.hidden;
  ctx.fillRect(sx + pad, sy + pad, c - pad * 2, c - pad * 2);
  ctx.fillStyle = COLORS.cell.borderLight;
  const hl = Math.max(1, c * 0.08);
  ctx.fillRect(sx + pad, sy + pad, c - pad * 2, hl);
  ctx.fillRect(sx + pad, sy + pad, hl, c - pad * 2);
  if (isFlagged) drawFlag(sx, sy, c);
}

function drawRevealedCell(sx, sy, c, isMine, isHitMine, cx, cy) {
  const pad = Math.max(1, c * 0.04);
  if (isHitMine) {
    // Pulsing red for hit mine
    ctx.fillStyle = '#3d0012';
    ctx.fillRect(sx + pad, sy + pad, c - pad * 2, c - pad * 2);
    ctx.fillStyle = 'rgba(255, 45, 107, 0.25)';
    ctx.fillRect(sx + pad, sy + pad, c - pad * 2, c - pad * 2);
  } else {
    ctx.fillStyle = COLORS.cell.revealed;
    ctx.fillRect(sx + pad, sy + pad, c - pad * 2, c - pad * 2);
  }
  if (isMine) drawMine(sx, sy, c, isHitMine);
  else {
    const count = countMines(cx, cy);
    if (count > 0) drawNumber(sx, sy, c, count);
  }
}

function drawFlag(sx, sy, c) {
  const cx = sx + c / 2;
  const cy = sy + c / 2;
  const s = c * 0.28;

  // Pole
  const poleW = Math.max(1.5, c * 0.065);
  const poleH = s * 2.2;
  const poleX = cx - poleW / 2;
  const poleTop = cy - s * 1.0;
  const poleBot = cy + s * 1.2;

  // Draw shadow
  ctx.save();
  ctx.shadowColor = 'rgba(0,0,0,0.4)';
  ctx.shadowBlur = c * 0.15;

  // Base / stand
  ctx.fillStyle = '#4a5280';
  ctx.beginPath();
  ctx.ellipse(cx, poleBot, s * 0.7, s * 0.2, 0, 0, Math.PI * 2);
  ctx.fill();

  // Pole
  const grad = ctx.createLinearGradient(poleX, 0, poleX + poleW * 3, 0);
  grad.addColorStop(0, '#6a7090');
  grad.addColorStop(1, '#b0b8d0');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.roundRect(poleX, poleTop, poleW, poleH, poleW / 2);
  ctx.fill();

  // Flag body - sleek triangle
  const flagGrad = ctx.createLinearGradient(cx, poleTop, cx + s * 1.4, poleTop + s * 0.9);
  flagGrad.addColorStop(0, '#ff2d6b');
  flagGrad.addColorStop(1, '#ff6b2d');
  ctx.fillStyle = flagGrad;
  ctx.beginPath();
  ctx.moveTo(cx, poleTop);
  ctx.lineTo(cx + s * 1.5, poleTop + s * 0.55);
  ctx.lineTo(cx, poleTop + s * 1.1);
  ctx.closePath();
  ctx.fill();

  // Highlight on flag
  ctx.fillStyle = 'rgba(255,255,255,0.2)';
  ctx.beginPath();
  ctx.moveTo(cx, poleTop);
  ctx.lineTo(cx + s * 1.5, poleTop + s * 0.55);
  ctx.lineTo(cx, poleTop + s * 0.3);
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}

function drawMine(sx, sy, c, isHit) {
  const cx = sx + c / 2;
  const cy = sy + c / 2;
  const r = c * 0.22;

  ctx.save();
  ctx.shadowColor = isHit ? '#ff2d6b' : 'rgba(0,0,0,0.5)';
  ctx.shadowBlur = isHit ? c * 0.4 : c * 0.2;

  // Body
  const bodyGrad = ctx.createRadialGradient(cx - r * 0.3, cy - r * 0.3, r * 0.1, cx, cy, r);
  bodyGrad.addColorStop(0, isHit ? '#ff6b8a' : '#4a5066');
  bodyGrad.addColorStop(1, isHit ? '#cc0033' : '#1a1e2e');
  ctx.fillStyle = bodyGrad;
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.fill();

  // Spikes
  ctx.strokeStyle = isHit ? '#ff2d6b' : '#3a3e56';
  ctx.lineWidth = Math.max(1, c * 0.06);
  ctx.lineCap = 'round';
  for (let i = 0; i < 8; i++) {
    const angle = (i * Math.PI) / 4;
    ctx.beginPath();
    ctx.moveTo(cx + Math.cos(angle) * r * 0.85, cy + Math.sin(angle) * r * 0.85);
    ctx.lineTo(cx + Math.cos(angle) * r * 1.65, cy + Math.sin(angle) * r * 1.65);
    ctx.stroke();
  }

  // Shine
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.beginPath();
  ctx.arc(cx - r * 0.28, cy - r * 0.28, r * 0.28, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

function drawNumber(sx, sy, c, count) {
  ctx.fillStyle = COLORS.numbers[count] || '#888';
  ctx.font = `700 ${Math.floor(c * 0.62)}px 'JetBrains Mono', monospace`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(count, sx + c / 2, sy + c / 2 + 1);
}

// Background animation
let bgParticles = [];

function initBackground() {
  bgCanvas.width = window.innerWidth;
  bgCanvas.height = window.innerHeight;
  bgParticles = [];
  for (let i = 0; i < 60; i++) {
    bgParticles.push({
      x: Math.random() * bgCanvas.width,
      y: Math.random() * bgCanvas.height,
      vx: (Math.random() - 0.5) * 0.4,
      vy: (Math.random() - 0.5) * 0.4,
      size: Math.random() * 1.5 + 0.5,
      opacity: Math.random() * 0.4 + 0.1,
    });
  }
  animateBackground();
}

function animateBackground() {
  bgCtx.fillStyle = 'rgba(8, 12, 24, 0.12)';
  bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
  bgParticles.forEach(p => {
    p.x += p.vx; p.y += p.vy;
    if (p.x < 0 || p.x > bgCanvas.width) p.vx *= -1;
    if (p.y < 0 || p.y > bgCanvas.height) p.vy *= -1;
    bgCtx.fillStyle = `rgba(0, 212, 255, ${p.opacity})`;
    bgCtx.beginPath();
    bgCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    bgCtx.fill();
  });
  requestAnimationFrame(animateBackground);
}

function updateUI() {
  flagCountEl.textContent = gameState.flagged.size;
  undoCountEl.textContent = gameState.undoCount;
  revealedCountEl.textContent = gameState.revealedCount;
  currentSeedEl.value = gameState.seed;
}

function showGameOverModal() {
  modalIcon.textContent = 'üí•';
  modalTitle.textContent = 'Boom!';
  modalText.textContent = 'Vous avez touch√© une mine. Utilisez "Annuler" pour revenir en arri√®re.';
  modalActions.innerHTML = `
    <button class="btn btn-primary" onclick="modalOverlay.classList.remove('show'); undo();">
      <span class="btn-icon">‚Ü©</span> Annuler
    </button>
    <button class="btn" onclick="modalOverlay.classList.remove('show'); confirmNewGame();">
      <span class="btn-icon">‚ü≥</span> Nouveau jeu
    </button>
  `;
  modalOverlay.classList.add('show');
}

function showToast(type, title, message) {
  const toast = document.createElement('div');
  toast.className = `toast ${type}`;
  const icons = { success: '‚úì', error: '‚úï', info: '¬∑' };
  toast.innerHTML = `
    <div class="toast-icon">${icons[type]}</div>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      <div class="toast-message">${message}</div>
    </div>
  `;
  toastContainer.appendChild(toast);
  setTimeout(() => {
    toast.style.opacity = '0';
    toast.style.transform = 'translateX(100%)';
    toast.style.transition = 'all 0.3s ease';
    setTimeout(() => toast.remove(), 300);
  }, 3000);
}

let confirmCallback = null;

function showConfirmModal(title, text, onConfirm) {
  modalIcon.textContent = '‚ö†Ô∏è';
  modalTitle.textContent = title;
  modalText.textContent = text;
  confirmCallback = onConfirm;
  modalActions.innerHTML = `
    <button class="btn btn-primary" id="modal-confirm-dyn"><span class="btn-icon">‚úì</span> Confirmer</button>
    <button class="btn" id="modal-cancel-dyn"><span class="btn-icon">‚úï</span> Annuler</button>
  `;
  document.getElementById('modal-confirm-dyn').addEventListener('click', () => {
    modalOverlay.classList.remove('show');
    if (confirmCallback) { confirmCallback(); confirmCallback = null; }
  });
  document.getElementById('modal-cancel-dyn').addEventListener('click', () => {
    modalOverlay.classList.remove('show');
    confirmCallback = null;
  });
  modalOverlay.classList.add('show');
}

function confirmNewGame() {
  if (gameState.revealedCount > 10 && !gameState.gameOver) {
    showConfirmModal('Nouvelle partie ?', 'Vous avez d√©j√† r√©v√©l√© plusieurs cases. Voulez-vous vraiment recommencer ?', () => newGame());
  } else newGame();
}

function saveGame(showNotification = false) {
  const saveData = {
    seed: gameState.seed,
    revealed: Array.from(gameState.revealed),
    flagged: Array.from(gameState.flagged),
    safeCells: Array.from(gameState.safeCells),
    firstClick: gameState.firstClick,
    revealedCount: gameState.revealedCount,
    undoCount: gameState.undoCount,
    timestamp: Date.now(),
  };
  try {
    localStorage.setItem('minesweeper_save', JSON.stringify(saveData));
    if (showNotification) showToast('success', 'Partie sauvegard√©e', 'Votre progression a √©t√© enregistr√©e');
  } catch (e) {
    if (showNotification) showToast('error', 'Erreur', 'Impossible de sauvegarder la partie');
  }
}

function loadGame() {
  try {
    const data = localStorage.getItem('minesweeper_save');
    if (!data) return false;
    const saveData = JSON.parse(data);
    gameState.seed = saveData.seed;
    gameState.rng = new SeededRandom(gameState.seed);
    gameState.revealed = new Set(saveData.revealed);
    gameState.flagged = new Set(saveData.flagged);
    gameState.safeCells = new Set(saveData.safeCells);
    gameState.firstClick = saveData.firstClick;
    gameState.revealedCount = saveData.revealedCount || saveData.revealed.length;
    gameState.undoCount = saveData.undoCount || 0;
    gameState.gameOver = false;
    gameState.dead = false;
    gameState.mineHit = null;
    gameState.undoStack = [];
    updateUI();
    viewState.dirtyRender = true;
    requestRender();
    return true;
  } catch (e) {
    console.error('Load error:', e);
    return false;
  }
}

function exportGame() {
  const exportData = { v: 1, s: gameState.seed, r: Array.from(gameState.revealed), f: Array.from(gameState.flagged) };
  const encoded = btoa(JSON.stringify(exportData));
  navigator.clipboard.writeText(encoded)
    .then(() => showToast('success', 'Code export√©!', 'Copi√© dans votre presse-papier'))
    .catch(() => showToast('error', 'Erreur', 'Impossible de copier le code'));
}

function importGame(code) {
  try {
    const decoded = JSON.parse(atob(code));
    if (decoded.v !== 1) { showToast('error', 'Version incompatible', 'Ce code n\'est pas compatible'); return; }
    gameState.seed = decoded.s;
    gameState.rng = new SeededRandom(gameState.seed);
    gameState.revealed = new Set(decoded.r);
    gameState.flagged = new Set(decoded.f);
    gameState.safeCells = new Set();
    gameState.firstClick = false;
    gameState.revealedCount = decoded.r.length;
    gameState.gameOver = false;
    gameState.dead = false;
    gameState.mineHit = null;
    gameState.undoCount = 0;
    gameState.undoStack = [];
    updateUI();
    viewState.dirtyRender = true;
    requestRender();
    showToast('success', 'Partie import√©e', 'Le jeu a √©t√© restaur√© avec succ√®s');
  } catch (e) {
    showToast('error', 'Code invalide', 'Le code fourni est invalide ou corrompu');
  }
}

function newGame(customSeed = null) {
  gameState.seed = customSeed || generateRandomSeed();
  gameState.rng = new SeededRandom(gameState.seed);
  gameState.revealed = new Set();
  gameState.flagged = new Set();
  gameState.safeCells = new Set();
  gameState.gameOver = false;
  gameState.dead = false;
  gameState.firstClick = true;
  gameState.mineHit = null;
  gameState.undoCount = 0;
  gameState.undoStack = [];
  gameState.revealedCount = 0;
  viewState.zoom = 1.0;
  viewState.offX = viewState.W / 2 - 6 * CONFIG.BASE_CELL;
  viewState.offY = viewState.H / 2 - 6 * CONFIG.BASE_CELL;
  modalOverlay.classList.remove('show');
  updateUI();
  viewState.dirtyRender = true;
  requestRender();
  showToast('info', 'Nouveau jeu', `Seed : ${gameState.seed}`);
}

function resize() {
  const rect = canvasWrap.getBoundingClientRect();
  const newW = Math.floor(rect.width);
  const newH = Math.floor(rect.height);
  if (newW === viewState.W && newH === viewState.H) return;
  const fx = viewState.W ? viewState.offX / viewState.W : 0.5;
  const fy = viewState.H ? viewState.offY / viewState.H : 0.5;
  viewState.W = canvas.width = newW;
  viewState.H = canvas.height = newH;
  viewState.offX = fx * newW;
  viewState.offY = fy * newH;
  viewState.dirtyRender = true;
  requestRender();
}

const resizeObserver = new ResizeObserver(resize);
resizeObserver.observe(canvasWrap);

// Mouse events
canvas.addEventListener('mousedown', e => {
  if (e.button === 1 || e.ctrlKey) {
    viewState.panning = true;
    viewState.didPan = false;
    viewState.panStartX = e.clientX;
    viewState.panStartY = e.clientY;
    viewState.panOffX0 = viewState.offX;
    viewState.panOffY0 = viewState.offY;
    canvas.classList.add('panning');
    e.preventDefault();
  }
});

canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  const [cx, cy] = screenToCell(e.clientX - rect.left, e.clientY - rect.top);
  if (viewState.panning) {
    const dx = e.clientX - viewState.panStartX;
    const dy = e.clientY - viewState.panStartY;
    if (Math.abs(dx) > 2 || Math.abs(dy) > 2) viewState.didPan = true;
    viewState.offX = viewState.panOffX0 + dx;
    viewState.offY = viewState.panOffY0 + dy;
    viewState.dirtyRender = true;
    requestRender();
  } else {
    if (!viewState.hoverCell || viewState.hoverCell[0] !== cx || viewState.hoverCell[1] !== cy) {
      viewState.hoverCell = [cx, cy];
      viewState.dirtyRender = true;
      requestRender();
    }
  }
});

canvas.addEventListener('mouseup', () => { viewState.panning = false; canvas.classList.remove('panning'); });
canvas.addEventListener('mouseleave', () => {
  viewState.panning = false;
  canvas.classList.remove('panning');
  viewState.hoverCell = null;
  viewState.dirtyRender = true;
  requestRender();
});

canvas.addEventListener('click', e => {
  if (viewState.didPan) { viewState.didPan = false; return; }
  if (e.ctrlKey) return;
  const rect = canvas.getBoundingClientRect();
  const [cx, cy] = screenToCell(e.clientX - rect.left, e.clientY - rect.top);
  reveal(cx, cy);
});

canvas.addEventListener('contextmenu', e => {
  e.preventDefault();
  if (viewState.didPan) return;
  const rect = canvas.getBoundingClientRect();
  const [cx, cy] = screenToCell(e.clientX - rect.left, e.clientY - rect.top);
  toggleFlag(cx, cy);
});

canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left, my = e.clientY - rect.top;
  const factor = e.deltaY < 0 ? 1.15 : 1 / 1.15;
  const newZoom = Math.min(CONFIG.ZOOM_MAX, Math.max(CONFIG.ZOOM_MIN, viewState.zoom * factor));
  const scale = newZoom / viewState.zoom;
  viewState.offX = mx - scale * (mx - viewState.offX);
  viewState.offY = my - scale * (my - viewState.offY);
  viewState.zoom = newZoom;
  viewState.hiddenTexture = null;
  viewState.dirtyRender = true;
  requestRender();
}, { passive: false });

// Touch events
let lastTouchDist = null, lastTouchCx, lastTouchCy;

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  if (e.touches.length === 2) {
    lastTouchDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
    lastTouchCx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
    lastTouchCy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
  } else {
    viewState.panning = true;
    viewState.didPan = false;
    viewState.panStartX = e.touches[0].clientX;
    viewState.panStartY = e.touches[0].clientY;
    viewState.panOffX0 = viewState.offX;
    viewState.panOffY0 = viewState.offY;
    lastTouchDist = null;
  }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  if (e.touches.length === 2 && lastTouchDist !== null) {
    const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
    const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
    const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
    const rect = canvas.getBoundingClientRect();
    const mx = cx - rect.left, my = cy - rect.top;
    const newZoom = Math.min(CONFIG.ZOOM_MAX, Math.max(CONFIG.ZOOM_MIN, viewState.zoom * (dist / lastTouchDist)));
    const scale = newZoom / viewState.zoom;
    viewState.offX = mx - scale * (mx - viewState.offX) + (cx - lastTouchCx);
    viewState.offY = my - scale * (my - viewState.offY) + (cy - lastTouchCy);
    viewState.zoom = newZoom;
    lastTouchDist = dist; lastTouchCx = cx; lastTouchCy = cy;
    viewState.hiddenTexture = null;
    viewState.dirtyRender = true;
    requestRender();
  } else if (e.touches.length === 1 && viewState.panning) {
    const dx = e.touches[0].clientX - viewState.panStartX;
    const dy = e.touches[0].clientY - viewState.panStartY;
    if (Math.abs(dx) > 2 || Math.abs(dy) > 2) viewState.didPan = true;
    viewState.offX = viewState.panOffX0 + dx;
    viewState.offY = viewState.panOffY0 + dy;
    viewState.dirtyRender = true;
    requestRender();
  }
}, { passive: false });

canvas.addEventListener('touchend', e => {
  e.preventDefault();
  if (e.changedTouches.length === 1 && !viewState.didPan && e.touches.length === 0) {
    const touch = e.changedTouches[0];
    const rect = canvas.getBoundingClientRect();
    const [cx, cy] = screenToCell(touch.clientX - rect.left, touch.clientY - rect.top);
    if (gameState.mobileMode === 'reveal') reveal(cx, cy);
    else toggleFlag(cx, cy);
  }
  viewState.panning = false;
  viewState.didPan = false;
  lastTouchDist = null;
}, { passive: false });

// Mobile mode buttons
mobileRevealBtn.addEventListener('click', () => {
  gameState.mobileMode = 'reveal';
  mobileRevealBtn.classList.add('active');
  mobileFlagBtn.classList.remove('active');
});
mobileFlagBtn.addEventListener('click', () => {
  gameState.mobileMode = 'flag';
  mobileFlagBtn.classList.add('active');
  mobileRevealBtn.classList.remove('active');
});

// Keyboard shortcuts
document.addEventListener('keydown', e => {
  if (e.ctrlKey && e.key === 'z') { e.preventDefault(); undo(); }
  if (e.ctrlKey && e.key === 'r') { e.preventDefault(); confirmNewGame(); }
  if (e.ctrlKey && e.key === 's') { e.preventDefault(); saveGame(true); }
});

// Buttons
newGameBtn.addEventListener('click', confirmNewGame);
undoBtn.addEventListener('click', undo);
saveBtn.addEventListener('click', () => saveGame(true));
exportBtn.addEventListener('click', exportGame);

applySeedBtn.addEventListener('click', () => {
  const seed = seedInputEl.value.trim();
  newGame(seed || null);
});

importBtn.addEventListener('click', () => {
  const code = importInputEl.value.trim();
  if (code) { importGame(code); importInputEl.value = ''; }
});

document.addEventListener('click', e => {
  if (window.innerWidth <= 768 && sidebar.classList.contains('show')) {
    if (!sidebar.contains(e.target) && e.target !== sidebarToggleMobile) {
      sidebar.classList.remove('show');
    }
  }
});

modalOverlay.addEventListener('click', e => {
  if (e.target === modalOverlay) modalOverlay.classList.remove('show');
});

// Auto-save
setInterval(() => {
  if (gameState.revealedCount > 0 && !gameState.gameOver) saveGame(false);
}, CONFIG.AUTO_SAVE_INTERVAL);

// Init
window.addEventListener('load', () => {
  const rect = canvasWrap.getBoundingClientRect();
  viewState.W = canvas.width = Math.floor(rect.width);
  viewState.H = canvas.height = Math.floor(rect.height);
  initBackground();
  if (!loadGame()) newGame();
  viewState.dirtyRender = true;
  requestRender();
  window.addEventListener('resize', () => {
    bgCanvas.width = window.innerWidth;
    bgCanvas.height = window.innerHeight;
  });
});
</script>
</body>
</html>
