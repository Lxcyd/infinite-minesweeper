<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>‚ôæÔ∏è D√©mineur Infini</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

*, *::before, *::after {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

:root {
  --bg-main: #0a0e1a;
  --bg-panel: rgba(20, 25, 40, 0.7);
  --bg-card: rgba(30, 35, 50, 0.8);
  --accent-primary: #00d4ff;
  --accent-secondary: #ff006e;
  --accent-success: #00ff88;
  --accent-warning: #ffaa00;
  --text-primary: #ffffff;
  --text-secondary: #a0aec0;
  --border-color: rgba(255, 255, 255, 0.1);
  --shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
  --glow: 0 0 20px rgba(0, 212, 255, 0.3);
}

html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: var(--bg-main);
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  color: var(--text-primary);
}

#bg-canvas {
  position: fixed;
  inset: 0;
  z-index: 0;
  opacity: 0.3;
}

#app {
  position: fixed;
  inset: 0;
  display: flex;
  flex-direction: column;
  z-index: 1;
}

#header {
  flex: 0 0 auto;
  backdrop-filter: blur(20px);
  background: var(--bg-panel);
  border-bottom: 1px solid var(--border-color);
  padding: 16px 24px;
  display: flex;
  align-items: center;
  gap: 24px;
  box-shadow: var(--shadow);
}

#logo {
  display: flex;
  align-items: center;
  gap: 12px;
  font-size: 20px;
  font-weight: 700;
  letter-spacing: -0.5px;
}

#logo-icon {
  font-size: 28px;
  filter: drop-shadow(0 0 8px var(--accent-primary));
}

.header-stats {
  display: flex;
  gap: 20px;
  margin-left: auto;
}

.stat-card {
  backdrop-filter: blur(10px);
  background: var(--bg-card);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 8px 16px;
  display: flex;
  flex-direction: column;
  gap: 2px;
  min-width: 100px;
  transition: all 0.3s ease;
}

.stat-card:hover {
  transform: translateY(-2px);
  box-shadow: var(--glow);
}

.stat-label {
  font-size: 11px;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
}

.stat-value {
  font-size: 24px;
  font-weight: 700;
  font-variant-numeric: tabular-nums;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.btn-group {
  display: flex;
  gap: 8px;
}

.btn {
  backdrop-filter: blur(10px);
  background: var(--bg-card);
  border: 1px solid var(--border-color);
  border-radius: 10px;
  padding: 10px 18px;
  font-family: inherit;
  font-size: 14px;
  font-weight: 600;
  color: var(--text-primary);
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  gap: 8px;
  white-space: nowrap;
}

.btn:hover {
  background: rgba(50, 55, 70, 0.9);
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(0, 212, 255, 0.2);
}

.btn:active {
  transform: translateY(0);
}

.btn-primary {
  background: linear-gradient(135deg, var(--accent-primary), #0099cc);
  border: none;
  box-shadow: 0 4px 16px rgba(0, 212, 255, 0.3);
}

.btn-primary:hover {
  box-shadow: 0 6px 20px rgba(0, 212, 255, 0.4);
  transform: translateY(-2px);
}

.btn-icon {
  font-size: 18px;
}

#game-container {
  flex: 1 1 0;
  display: flex;
  min-height: 0;
  position: relative;
}

#canvas-wrap {
  flex: 1 1 0;
  position: relative;
  overflow: hidden;
  cursor: crosshair;
}

#canvas {
  display: block;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
}

#canvas.panning {
  cursor: grab;
}

#mobile-controls {
  display: none;
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 50;
  gap: 16px;
}

.mobile-mode-btn {
  width: 70px;
  height: 70px;
  backdrop-filter: blur(20px);
  background: var(--bg-card);
  border: 2px solid var(--border-color);
  border-radius: 50%;
  font-size: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
}

.mobile-mode-btn:active {
  transform: scale(0.95);
}

.mobile-mode-btn.active {
  border-color: var(--accent-primary);
  background: rgba(0, 212, 255, 0.2);
  box-shadow: 0 0 24px rgba(0, 212, 255, 0.5);
}

#sidebar {
  flex: 0 0 auto;
  width: 320px;
  backdrop-filter: blur(20px);
  background: var(--bg-panel);
  border-left: 1px solid var(--border-color);
  padding: 24px;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 20px;
  transition: width 0.3s ease, padding 0.3s ease;
}

#sidebar.collapsed {
  width: 60px;
  padding: 24px 12px;
}

#sidebar.collapsed .panel-content {
  display: none;
}

#sidebar.collapsed .panel-title span:not(.panel-icon) {
  display: none;
}

#sidebar-toggle-btn {
  position: sticky;
  top: 0;
  width: 100%;
  margin-bottom: 12px;
  z-index: 10;
}

.panel {
  backdrop-filter: blur(10px);
  background: var(--bg-card);
  border: 1px solid var(--border-color);
  border-radius: 16px;
  padding: 20px;
  transition: all 0.3s ease;
}

#sidebar.collapsed .panel {
  padding: 12px;
}

.panel-title {
  font-size: 14px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 16px;
  display: flex;
  align-items: center;
  gap: 8px;
}

#sidebar.collapsed .panel-title {
  justify-content: center;
  margin-bottom: 0;
}

.panel-icon {
  font-size: 18px;
}

.panel-content {
  transition: opacity 0.3s ease;
}

.input-group {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-bottom: 12px;
}

.input-group label {
  font-size: 13px;
  font-weight: 500;
  color: var(--text-secondary);
}

.input-group input {
  backdrop-filter: blur(10px);
  background: rgba(10, 14, 26, 0.6);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 10px 12px;
  font-family: 'Courier New', monospace;
  font-size: 14px;
  color: var(--text-primary);
  transition: all 0.2s ease;
}

.input-group input:focus {
  outline: none;
  border-color: var(--accent-primary);
  box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.1);
}

.input-group input::placeholder {
  color: var(--text-secondary);
  opacity: 0.5;
}

.btn-small {
  padding: 8px 14px;
  font-size: 13px;
}

.help-text {
  font-size: 12px;
  color: var(--text-secondary);
  line-height: 1.5;
  margin-top: 8px;
}

.shortcut-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.shortcut-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: rgba(10, 14, 26, 0.4);
  border-radius: 8px;
  font-size: 12px;
}

.shortcut-key {
  background: rgba(255, 255, 255, 0.1);
  padding: 4px 8px;
  border-radius: 4px;
  font-family: 'Courier New', monospace;
  font-size: 11px;
  font-weight: 600;
}

#modal-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(8px);
  z-index: 100;
  align-items: center;
  justify-content: center;
  animation: fadeIn 0.3s ease;
}

#modal-overlay.show {
  display: flex;
}

.modal {
  backdrop-filter: blur(20px);
  background: var(--bg-card);
  border: 1px solid var(--border-color);
  border-radius: 24px;
  padding: 40px;
  max-width: 500px;
  text-align: center;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
  animation: slideUp 0.3s ease;
}

.modal-icon {
  font-size: 72px;
  margin-bottom: 20px;
  filter: drop-shadow(0 0 20px currentColor);
}

.modal-title {
  font-size: 32px;
  font-weight: 700;
  margin-bottom: 12px;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.modal-text {
  font-size: 16px;
  color: var(--text-secondary);
  margin-bottom: 30px;
}

.modal-actions {
  display: flex;
  gap: 12px;
  justify-content: center;
  flex-wrap: wrap;
}

#toast-container {
  position: fixed;
  top: 80px;
  right: 24px;
  z-index: 200;
  display: flex;
  flex-direction: column;
  gap: 12px;
  pointer-events: none;
}

.toast {
  backdrop-filter: blur(20px);
  background: var(--bg-card);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 16px 20px;
  display: flex;
  align-items: center;
  gap: 12px;
  box-shadow: var(--shadow);
  animation: slideInRight 0.3s ease;
  pointer-events: all;
  min-width: 280px;
}

.toast-icon {
  font-size: 24px;
}

.toast-content {
  flex: 1;
}

.toast-title {
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 2px;
}

.toast-message {
  font-size: 12px;
  color: var(--text-secondary);
}

.toast.success .toast-icon {
  color: var(--accent-success);
}

.toast.error .toast-icon {
  color: var(--accent-secondary);
}

.toast.info .toast-icon {
  color: var(--accent-primary);
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideInRight {
  from {
    opacity: 0;
    transform: translateX(100%);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@media (max-width: 768px) {
  #header {
    flex-wrap: wrap;
    padding: 12px 16px;
    gap: 12px;
  }

  .header-stats {
    order: 3;
    width: 100%;
    justify-content: space-between;
  }

  .stat-card {
    min-width: auto;
    flex: 1;
  }

  #sidebar {
    position: fixed;
    right: -100%;
    top: 0;
    height: 100%;
    z-index: 50;
    transition: right 0.3s ease;
  }

  #sidebar.show {
    right: 0;
  }

  #sidebar.collapsed {
    right: -100%;
  }

  .btn-group {
    flex-wrap: wrap;
  }

  #mobile-controls {
    display: flex;
  }

  #toast-container {
    right: 12px;
    left: 12px;
  }

  .toast {
    min-width: auto;
  }
}

::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.2);
}

::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.2);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.3);
}
</style>
</head>
<body>

<canvas id="bg-canvas"></canvas>

<div id="toast-container"></div>

<div id="modal-overlay">
  <div class="modal">
    <div class="modal-icon" id="modal-icon">üí•</div>
    <div class="modal-title" id="modal-title">Boom!</div>
    <div class="modal-text" id="modal-text">Vous avez touch√© une mine</div>
    <div class="modal-actions" id="modal-actions">
      <button class="btn btn-primary" id="modal-confirm">
        <span class="btn-icon">‚úì</span>
        Confirmer
      </button>
      <button class="btn" id="modal-cancel">
        <span class="btn-icon">‚úï</span>
        Annuler
      </button>
    </div>
  </div>
</div>

<div id="app">
  
  <div id="header">
    <div id="logo">
      <span id="logo-icon">‚ôæÔ∏è</span>
      <span>D√©mineur Infini</span>
    </div>

    <div class="btn-group">
      <button class="btn btn-primary" id="new-game-btn" title="Ctrl+R">
        <span class="btn-icon">üîÑ</span>
        Nouveau
      </button>
      <button class="btn" id="undo-btn" title="Ctrl+Z">
        <span class="btn-icon">‚Ü©</span>
        Annuler
      </button>
      <button class="btn" id="save-btn" title="Ctrl+S">
        <span class="btn-icon">üíæ</span>
        Sauvegarder
      </button>
      <button class="btn" id="export-btn" title="Exporter">
        <span class="btn-icon">üì§</span>
        Export
      </button>
      <button class="btn" id="sidebar-toggle-mobile">
        <span class="btn-icon">‚öôÔ∏è</span>
      </button>
    </div>

    <div class="header-stats">
      <div class="stat-card">
        <div class="stat-label">üö© Drapeaux</div>
        <div class="stat-value" id="flag-count">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">‚Ü© Retours</div>
        <div class="stat-value" id="undo-count">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">üìç Cellules</div>
        <div class="stat-value" id="revealed-count">0</div>
      </div>
    </div>
  </div>

  <div id="game-container">
    <div id="canvas-wrap">
      <canvas id="canvas"></canvas>
    </div>

    <div id="mobile-controls">
      <button class="mobile-mode-btn active" id="mobile-reveal" title="Mode r√©v√©lation">
        üí°
      </button>
      <button class="mobile-mode-btn" id="mobile-flag" title="Mode drapeau">
        üö©
      </button>
    </div>

    <div id="sidebar">
      <button class="btn" id="sidebar-toggle-btn">
        <span class="btn-icon" id="sidebar-toggle-icon">‚óÄ</span>
      </button>

      <div class="panel">
        <div class="panel-title">
          <span class="panel-icon">üé≤</span>
          <span>Seed & G√©n√©ration</span>
        </div>
        
        <div class="panel-content">
          <div class="input-group">
            <label for="seed-input">Seed (laisser vide pour al√©atoire)</label>
            <input type="text" id="seed-input" placeholder="Ex: minecraft123">
          </div>

          <button class="btn btn-small" id="apply-seed-btn" style="width: 100%;">
            <span class="btn-icon">‚ú®</span>
            Appliquer seed
          </button>

          <div class="help-text">
            La seed permet de g√©n√©rer toujours la m√™me carte. Partagez-la avec vos amis!
          </div>

          <div class="input-group" style="margin-top: 16px;">
            <label>Seed actuelle</label>
            <input type="text" id="current-seed" readonly style="opacity: 0.7;">
          </div>
        </div>
      </div>

      <div class="panel">
        <div class="panel-title">
          <span class="panel-icon">üíæ</span>
          <span>Import / Export</span>
        </div>

        <div class="panel-content">
          <div class="input-group">
            <label for="import-input">Coller un code de partie</label>
            <input type="text" id="import-input" placeholder="Collez le code ici...">
          </div>

          <button class="btn btn-small" id="import-btn" style="width: 100%;">
            <span class="btn-icon">üì•</span>
            Importer partie
          </button>

          <div class="help-text">
            Le code contient la seed, les cellules r√©v√©l√©es et les drapeaux.
          </div>
        </div>
      </div>

      <div class="panel">
        <div class="panel-title">
          <span class="panel-icon">‚å®Ô∏è</span>
          <span>Raccourcis</span>
        </div>

        <div class="panel-content">
          <div class="shortcut-list">
            <div class="shortcut-item">
              <span>R√©v√©ler case</span>
              <span class="shortcut-key">Clic gauche</span>
            </div>
            <div class="shortcut-item">
              <span>Placer drapeau</span>
              <span class="shortcut-key">Clic droit</span>
            </div>
            <div class="shortcut-item">
              <span>Chord (auto)</span>
              <span class="shortcut-key">Clic sur num√©ro</span>
            </div>
            <div class="shortcut-item">
              <span>D√©placer vue</span>
              <span class="shortcut-key">Ctrl + Glisser</span>
            </div>
            <div class="shortcut-item">
              <span>Zoom</span>
              <span class="shortcut-key">Molette</span>
            </div>
            <div class="shortcut-item">
              <span>Annuler</span>
              <span class="shortcut-key">Ctrl + Z</span>
            </div>
            <div class="shortcut-item">
              <span>Nouveau jeu</span>
              <span class="shortcut-key">Ctrl + R</span>
            </div>
            <div class="shortcut-item">
              <span>Sauvegarder</span>
              <span class="shortcut-key">Ctrl + S</span>
            </div>
          </div>
        </div>
      </div>

      <div class="help-text" style="padding: 16px; background: rgba(0, 212, 255, 0.1); border-radius: 12px; border: 1px solid rgba(0, 212, 255, 0.2);">
        üí° <strong>Astuce Chord :</strong> Quand un num√©ro est r√©v√©l√© avec le bon nombre de drapeaux autour, cliquez dessus pour r√©v√©ler automatiquement toutes les cellules s√ªres adjacentes ! C'est une technique pro pour gagner du temps.
      </div>
    </div>
  </div>

</div>

<script>
const CONFIG = {
  BASE_CELL: 24,
  MINE_PCT: 18,
  SAFE_RADIUS: 4,
  MAX_FLOOD: 30000,
  MAX_UNDO: 100,
  ZOOM_MIN: 0.15,
  ZOOM_MAX: 5,
  ZOOM_TEXTURE_THRESHOLD: 0.4,
  AUTO_SAVE_INTERVAL: 10000,
  RENDER_CULLING: 2,
};

const COLORS = {
  numbers: [
    null,
    '#2196F3',
    '#4CAF50',
    '#F44336',
    '#9C27B0',
    '#FF9800',
    '#00BCD4',
    '#795548',
    '#9E9E9E',
  ],
  cell: {
    revealed: '#2a3142',
    hidden: '#3d4663',
    hiddenHover: '#4a5270',
    border: '#1a1e2e',
    borderLight: '#5a607d',
  },
  mine: '#ff0044',
  flag: '#ffaa00',
};

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
const bgCanvas = document.getElementById('bg-canvas');
const bgCtx = bgCanvas.getContext('2d');

const flagCountEl = document.getElementById('flag-count');
const undoCountEl = document.getElementById('undo-count');
const revealedCountEl = document.getElementById('revealed-count');
const currentSeedEl = document.getElementById('current-seed');
const seedInputEl = document.getElementById('seed-input');
const importInputEl = document.getElementById('import-input');

const newGameBtn = document.getElementById('new-game-btn');
const undoBtn = document.getElementById('undo-btn');
const saveBtn = document.getElementById('save-btn');
const exportBtn = document.getElementById('export-btn');
const applySeedBtn = document.getElementById('apply-seed-btn');
const importBtn = document.getElementById('import-btn');
const sidebarToggleMobile = document.getElementById('sidebar-toggle-mobile');
const sidebarToggleBtn = document.getElementById('sidebar-toggle-btn');
const sidebarToggleIcon = document.getElementById('sidebar-toggle-icon');
const sidebar = document.getElementById('sidebar');

const modalOverlay = document.getElementById('modal-overlay');
const modalIcon = document.getElementById('modal-icon');
const modalTitle = document.getElementById('modal-title');
const modalText = document.getElementById('modal-text');
const modalActions = document.getElementById('modal-actions');
const modalConfirm = document.getElementById('modal-confirm');
const modalCancel = document.getElementById('modal-cancel');

const mobileRevealBtn = document.getElementById('mobile-reveal');
const mobileFlagBtn = document.getElementById('mobile-flag');

const canvasWrap = document.getElementById('canvas-wrap');
const toastContainer = document.getElementById('toast-container');

let gameState = {
  seed: '',
  rng: null,
  revealed: new Set(),
  flagged: new Set(),
  safeCells: new Set(),
  gameOver: false,
  dead: false,
  firstClick: true,
  mineHit: null,
  undoCount: 0,
  undoStack: [],
  revealedCount: 0,
  mobileMode: 'reveal',
};

let viewState = {
  W: 0,
  H: 0,
  offX: 0,
  offY: 0,
  zoom: 1.0,
  panning: false,
  panStartX: 0,
  panStartY: 0,
  panOffX0: 0,
  panOffY0: 0,
  didPan: false,
  hoverCell: null,
  dirtyRender: true,
  hiddenTexture: null,
};

class SeededRandom {
  constructor(seed) {
    this.state = this.hashString(seed);
  }

  hashString(str) {
    let h = 0;
    for (let i = 0; i < str.length; i++) {
      h = Math.imul(31, h) + str.charCodeAt(i) | 0;
    }
    return h >>> 0;
  }

  next() {
    let t = this.state += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }

  hashXY(x, y) {
    let h = Math.imul(x | 0, 0x9e3779b9) ^ Math.imul(y | 0, 0x6c62272e);
    h ^= this.state;
    h ^= h >>> 16;
    h = Math.imul(h, 0x45d9f3b);
    h ^= h >>> 16;
    return (h >>> 0) % 100;
  }
}

function hasMine(x, y) {
  const k = key(x, y);
  if (gameState.safeCells.has(k)) return false;
  return gameState.rng.hashXY(x, y) < CONFIG.MINE_PCT;
}

function countMines(x, y) {
  let count = 0;
  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      if (dx === 0 && dy === 0) continue;
      if (hasMine(x + dx, y + dy)) count++;
    }
  }
  return count;
}

const key = (x, y) => `${x},${y}`;
const cellSize = () => CONFIG.BASE_CELL * viewState.zoom;

function screenToCell(sx, sy) {
  const c = cellSize();
  return [
    Math.floor((sx - viewState.offX) / c),
    Math.floor((sy - viewState.offY) / c)
  ];
}

function cellToScreen(cx, cy) {
  const c = cellSize();
  return [
    cx * c + viewState.offX,
    cy * c + viewState.offY
  ];
}

function generateRandomSeed() {
  const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
  let seed = '';
  for (let i = 0; i < 12; i++) {
    seed += chars[Math.floor(Math.random() * chars.length)];
  }
  return seed;
}

function snapshot() {
  gameState.undoStack.push({
    revealed: new Set(gameState.revealed),
    flagged: new Set(gameState.flagged),
    safeCells: new Set(gameState.safeCells),
    gameOver: gameState.gameOver,
    dead: gameState.dead,
    firstClick: gameState.firstClick,
    mineHit: gameState.mineHit,
    revealedCount: gameState.revealedCount,
  });
  
  if (gameState.undoStack.length > CONFIG.MAX_UNDO) {
    gameState.undoStack.shift();
  }
}

function undo() {
  if (gameState.undoStack.length === 0) {
    showToast('info', 'Impossible d\'annuler', 'Aucune action √† annuler');
    return;
  }

  const snap = gameState.undoStack.pop();
  gameState.revealed = snap.revealed;
  gameState.flagged = snap.flagged;
  gameState.safeCells = snap.safeCells;
  gameState.gameOver = snap.gameOver;
  gameState.dead = snap.dead;
  gameState.firstClick = snap.firstClick;
  gameState.mineHit = snap.mineHit;
  gameState.revealedCount = snap.revealedCount;
  gameState.undoCount++;

  if (gameState.gameOver) {
    modalOverlay.classList.remove('show');
  }

  updateUI();
  viewState.dirtyRender = true;
  requestRender();

  showToast('success', 'Action annul√©e', 'Retour en arri√®re effectu√©');
}

function buildSafeZone(ox, oy) {
  gameState.safeCells.clear();
  for (let dy = -CONFIG.SAFE_RADIUS; dy <= CONFIG.SAFE_RADIUS; dy++) {
    for (let dx = -CONFIG.SAFE_RADIUS; dx <= CONFIG.SAFE_RADIUS; dx++) {
      gameState.safeCells.add(key(ox + dx, oy + dy));
    }
  }
}

function reveal(x, y) {
  if (gameState.gameOver) return;

  const k = key(x, y);
  
  if (gameState.revealed.has(k)) {
    chord(x, y);
    return;
  }
  
  if (gameState.flagged.has(k)) return;

  if (gameState.firstClick) {
    snapshot();
    buildSafeZone(x, y);
    gameState.firstClick = false;
  } else {
    snapshot();
  }

  if (hasMine(x, y)) {
    gameState.revealed.add(k);
    gameState.revealedCount++;
    gameState.dead = true;
    gameState.gameOver = true;
    gameState.mineHit = [x, y];

    showGameOverModal();
    updateUI();
    viewState.dirtyRender = true;
    requestRender();
    return;
  }

  const queue = [[x, y]];
  const seen = new Set([k]);
  let count = 0;

  while (queue.length > 0 && count < CONFIG.MAX_FLOOD) {
    const [cx, cy] = queue.shift();
    const ck = key(cx, cy);

    if (!gameState.revealed.has(ck)) {
      gameState.revealed.add(ck);
      gameState.revealedCount++;
      count++;
    }

    const mineCount = countMines(cx, cy);

    if (mineCount === 0) {
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = cx + dx;
          const ny = cy + dy;
          const nk = key(nx, ny);
          
          if (!seen.has(nk) && !hasMine(nx, ny) && !gameState.flagged.has(nk)) {
            seen.add(nk);
            queue.push([nx, ny]);
          }
        }
      }
    }
  }

  updateUI();
  viewState.dirtyRender = true;
  requestRender();
}

function chord(x, y) {
  const k = key(x, y);
  if (!gameState.revealed.has(k) || hasMine(x, y)) return;

  const mineCount = countMines(x, y);
  if (mineCount === 0) return;

  let flagCount = 0;
  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      if (dx === 0 && dy === 0) continue;
      if (gameState.flagged.has(key(x + dx, y + dy))) {
        flagCount++;
      }
    }
  }

  if (flagCount === mineCount) {
    snapshot();
    
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue;
        const nx = x + dx;
        const ny = y + dy;
        const nk = key(nx, ny);
        
        if (!gameState.revealed.has(nk) && !gameState.flagged.has(nk)) {
          reveal(nx, ny);
        }
      }
    }
  }
}

function toggleFlag(x, y) {
  if (gameState.gameOver) return;

  const k = key(x, y);
  if (gameState.revealed.has(k)) return;

  snapshot();

  if (gameState.flagged.has(k)) {
    gameState.flagged.delete(k);
  } else {
    gameState.flagged.add(k);
  }

  updateUI();
  viewState.dirtyRender = true;
  requestRender();
}

let renderQueued = false;

function requestRender() {
  if (!renderQueued) {
    renderQueued = true;
    requestAnimationFrame(() => {
      render();
      renderQueued = false;
    });
  }
}

function createHiddenTexture() {
  const size = CONFIG.BASE_CELL;
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = size;
  tempCanvas.height = size;
  const tempCtx = tempCanvas.getContext('2d');

  const padding = 1;
  
  tempCtx.fillStyle = COLORS.cell.hidden;
  tempCtx.fillRect(padding, padding, size - padding * 2, size - padding * 2);

  tempCtx.fillStyle = COLORS.cell.borderLight;
  tempCtx.fillRect(padding, padding, size - padding * 2, 2);
  tempCtx.fillRect(padding, padding, 2, size - padding * 2);

  return tempCanvas;
}

function render() {
  if (!viewState.dirtyRender) return;

  const c = cellSize();
  const { W, H, offX, offY } = viewState;

  ctx.fillStyle = COLORS.cell.border;
  ctx.fillRect(0, 0, W, H);

  const margin = CONFIG.RENDER_CULLING;
  const x0 = Math.floor(-offX / c) - margin;
  const y0 = Math.floor(-offY / c) - margin;
  const x1 = Math.ceil((W - offX) / c) + margin;
  const y1 = Math.ceil((H - offY) / c) + margin;

  const useTexture = viewState.zoom < CONFIG.ZOOM_TEXTURE_THRESHOLD;
  
  if (useTexture) {
    if (!viewState.hiddenTexture) {
      viewState.hiddenTexture = createHiddenTexture();
    }
    
    ctx.fillStyle = COLORS.cell.hidden;
    ctx.fillRect(0, 0, W, H);
    
    for (let cy = y0; cy <= y1; cy++) {
      for (let cx = x0; cx <= x1; cx++) {
        const k = key(cx, cy);
        if (gameState.revealed.has(k) || gameState.flagged.has(k)) {
          drawCell(cx, cy, c);
        }
      }
    }
  } else {
    for (let cy = y0; cy <= y1; cy++) {
      for (let cx = x0; cx <= x1; cx++) {
        drawCell(cx, cy, c);
      }
    }
  }

  if (viewState.hoverCell && !gameState.gameOver && !useTexture) {
    const [hx, hy] = viewState.hoverCell;
    const [sx, sy] = cellToScreen(hx, hy);
    ctx.strokeStyle = 'rgba(0, 212, 255, 0.5)';
    ctx.lineWidth = Math.max(2, c * 0.08);
    ctx.strokeRect(sx, sy, c, c);
  }

  viewState.dirtyRender = false;
}

function drawCell(cx, cy, c) {
  const k = key(cx, cy);
  const [sx, sy] = cellToScreen(cx, cy);

  if (sx + c < 0 || sx > viewState.W || sy + c < 0 || sy > viewState.H) {
    return;
  }

  const isRevealed = gameState.revealed.has(k);
  const isFlagged = gameState.flagged.has(k);
  const isMine = hasMine(cx, cy);
  const isHitMine = gameState.mineHit && gameState.mineHit[0] === cx && gameState.mineHit[1] === cy;

  if (isRevealed) {
    drawRevealedCell(sx, sy, c, isMine, isHitMine, cx, cy);
  } else {
    drawHiddenCell(sx, sy, c, isFlagged);
  }
}

function drawHiddenCell(sx, sy, c, isFlagged) {
  const padding = Math.max(1, c * 0.04);

  ctx.fillStyle = COLORS.cell.hidden;
  ctx.fillRect(sx + padding, sy + padding, c - padding * 2, c - padding * 2);

  ctx.fillStyle = COLORS.cell.borderLight;
  const highlightSize = Math.max(1, c * 0.08);
  ctx.fillRect(sx + padding, sy + padding, c - padding * 2, highlightSize);
  ctx.fillRect(sx + padding, sy + padding, highlightSize, c - padding * 2);

  if (isFlagged) {
    drawFlag(sx, sy, c);
  }
}

function drawRevealedCell(sx, sy, c, isMine, isHitMine, cx, cy) {
  const padding = Math.max(1, c * 0.04);

  ctx.fillStyle = isHitMine ? COLORS.mine : COLORS.cell.revealed;
  ctx.fillRect(sx + padding, sy + padding, c - padding * 2, c - padding * 2);

  if (isMine) {
    drawMine(sx, sy, c, isHitMine);
  } else {
    const count = countMines(cx, cy);
    if (count > 0) {
      drawNumber(sx, sy, c, count);
    }
  }
}

function drawFlag(sx, sy, c) {
  const centerX = sx + c / 2;
  const centerY = sy + c / 2;
  const size = c * 0.35;

  ctx.fillStyle = '#333';
  const poleWidth = Math.max(2, c * 0.08);
  ctx.fillRect(centerX - poleWidth / 2, centerY - size * 0.8, poleWidth, size * 1.6);

  ctx.fillStyle = COLORS.flag;
  ctx.beginPath();
  ctx.moveTo(centerX, centerY - size * 0.8);
  ctx.lineTo(centerX + size * 0.9, centerY - size * 0.25);
  ctx.lineTo(centerX, centerY + size * 0.3);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
  ctx.beginPath();
  ctx.moveTo(centerX, centerY - size * 0.7);
  ctx.lineTo(centerX + size * 0.7, centerY - size * 0.2);
  ctx.lineTo(centerX, centerY + size * 0.2);
  ctx.closePath();
  ctx.fill();
}

function drawMine(sx, sy, c, isHit) {
  const centerX = sx + c / 2;
  const centerY = sy + c / 2;
  const radius = c * 0.25;

  ctx.fillStyle = isHit ? '#ff0000' : '#222';
  ctx.beginPath();
  ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
  ctx.fill();

  ctx.strokeStyle = isHit ? '#ff0000' : '#222';
  ctx.lineWidth = Math.max(1, c * 0.08);
  const spikeLength = radius * 1.5;

  for (let i = 0; i < 8; i++) {
    const angle = (i * Math.PI) / 4;
    const x1 = centerX + Math.cos(angle) * radius;
    const y1 = centerY + Math.sin(angle) * radius;
    const x2 = centerX + Math.cos(angle) * spikeLength;
    const y2 = centerY + Math.sin(angle) * spikeLength;
    
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }

  if (!isHit) {
    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
    ctx.beginPath();
    ctx.arc(centerX - radius * 0.3, centerY - radius * 0.3, radius * 0.3, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawNumber(sx, sy, c, count) {
  ctx.fillStyle = COLORS.numbers[count] || '#000';
  ctx.font = `bold ${Math.floor(c * 0.65)}px Inter, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(count, sx + c / 2, sy + c / 2);
}

let bgParticles = [];

function initBackground() {
  bgCanvas.width = window.innerWidth;
  bgCanvas.height = window.innerHeight;

  bgParticles = [];
  for (let i = 0; i < 50; i++) {
    bgParticles.push({
      x: Math.random() * bgCanvas.width,
      y: Math.random() * bgCanvas.height,
      vx: (Math.random() - 0.5) * 0.5,
      vy: (Math.random() - 0.5) * 0.5,
      size: Math.random() * 2 + 1,
    });
  }

  animateBackground();
}

function animateBackground() {
  bgCtx.fillStyle = 'rgba(10, 14, 26, 0.1)';
  bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);

  bgParticles.forEach(p => {
    p.x += p.vx;
    p.y += p.vy;

    if (p.x < 0 || p.x > bgCanvas.width) p.vx *= -1;
    if (p.y < 0 || p.y > bgCanvas.height) p.vy *= -1;

    bgCtx.fillStyle = 'rgba(0, 212, 255, 0.3)';
    bgCtx.beginPath();
    bgCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    bgCtx.fill();
  });

  requestAnimationFrame(animateBackground);
}

function updateUI() {
  flagCountEl.textContent = gameState.flagged.size;
  undoCountEl.textContent = gameState.undoCount;
  revealedCountEl.textContent = gameState.revealedCount;
  currentSeedEl.value = gameState.seed;
}

function showGameOverModal() {
  modalIcon.textContent = 'üí•';
  modalTitle.textContent = 'Boom!';
  modalText.textContent = 'Vous avez touch√© une mine. Utilisez "Annuler" pour revenir en arri√®re.';
  
  modalActions.innerHTML = `
    <button class="btn btn-primary" onclick="modalOverlay.classList.remove('show'); undo();">
      <span class="btn-icon">‚Ü©</span>
      Annuler
    </button>
    <button class="btn" onclick="modalOverlay.classList.remove('show'); confirmNewGame();">
      <span class="btn-icon">üîÑ</span>
      Nouveau jeu
    </button>
  `;
  
  modalOverlay.classList.add('show');
}

function showToast(type, title, message) {
  const toast = document.createElement('div');
  toast.className = `toast ${type}`;
  
  const icons = {
    success: '‚úÖ',
    error: '‚ùå',
    info: '‚ÑπÔ∏è',
  };

  toast.innerHTML = `
    <div class="toast-icon">${icons[type]}</div>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      <div class="toast-message">${message}</div>
    </div>
  `;

  toastContainer.appendChild(toast);

  setTimeout(() => {
    toast.style.animation = 'slideInRight 0.3s ease reverse';
    setTimeout(() => toast.remove(), 300);
  }, 3000);
}

let confirmCallback = null;

function showConfirmModal(title, text, onConfirm) {
  modalIcon.textContent = '‚ö†Ô∏è';
  modalTitle.textContent = title;
  modalText.textContent = text;
  
  confirmCallback = onConfirm;
  modalOverlay.classList.add('show');
}

modalConfirm.addEventListener('click', () => {
  modalOverlay.classList.remove('show');
  if (confirmCallback) {
    confirmCallback();
    confirmCallback = null;
  }
});

modalCancel.addEventListener('click', () => {
  modalOverlay.classList.remove('show');
  confirmCallback = null;
});

function confirmNewGame() {
  if (gameState.revealedCount > 10 && !gameState.gameOver) {
    showConfirmModal(
      'Nouvelle partie ?',
      'Vous avez d√©j√† r√©v√©l√© plusieurs cellules. Voulez-vous vraiment recommencer ?',
      () => newGame()
    );
  } else {
    newGame();
  }
}

function saveGame(showNotification = false) {
  const saveData = {
    seed: gameState.seed,
    revealed: Array.from(gameState.revealed),
    flagged: Array.from(gameState.flagged),
    safeCells: Array.from(gameState.safeCells),
    firstClick: gameState.firstClick,
    revealedCount: gameState.revealedCount,
    undoCount: gameState.undoCount,
    timestamp: Date.now(),
  };

  try {
    localStorage.setItem('minesweeper_save', JSON.stringify(saveData));
    if (showNotification) {
      showToast('success', 'Partie sauvegard√©e', 'Votre progression a √©t√© enregistr√©e');
    }
  } catch (e) {
    if (showNotification) {
      showToast('error', 'Erreur', 'Impossible de sauvegarder la partie');
    }
  }
}

function loadGame() {
  try {
    const data = localStorage.getItem('minesweeper_save');
    if (!data) return false;

    const saveData = JSON.parse(data);
    
    gameState.seed = saveData.seed;
    gameState.rng = new SeededRandom(gameState.seed);
    gameState.revealed = new Set(saveData.revealed);
    gameState.flagged = new Set(saveData.flagged);
    gameState.safeCells = new Set(saveData.safeCells);
    gameState.firstClick = saveData.firstClick;
    gameState.revealedCount = saveData.revealedCount || saveData.revealed.length;
    gameState.undoCount = saveData.undoCount || 0;
    gameState.gameOver = false;
    gameState.dead = false;
    gameState.mineHit = null;
    gameState.undoStack = [];

    updateUI();
    viewState.dirtyRender = true;
    requestRender();

    return true;
  } catch (e) {
    console.error('Load error:', e);
    return false;
  }
}

function exportGame() {
  const exportData = {
    v: 1,
    s: gameState.seed,
    r: Array.from(gameState.revealed),
    f: Array.from(gameState.flagged),
  };

  const encoded = btoa(JSON.stringify(exportData));
  
  navigator.clipboard.writeText(encoded).then(() => {
    showToast('success', 'Code export√©!', 'Le code de partie a √©t√© copi√© dans votre presse-papier');
  }).catch(() => {
    showToast('error', 'Erreur', 'Impossible de copier le code');
  });
}

function importGame(code) {
  try {
    const decoded = JSON.parse(atob(code));
    
    if (decoded.v !== 1) {
      showToast('error', 'Version incompatible', 'Ce code n\'est pas compatible');
      return;
    }

    gameState.seed = decoded.s;
    gameState.rng = new SeededRandom(gameState.seed);
    gameState.revealed = new Set(decoded.r);
    gameState.flagged = new Set(decoded.f);
    gameState.safeCells = new Set();
    gameState.firstClick = false;
    gameState.revealedCount = decoded.r.length;
    gameState.gameOver = false;
    gameState.dead = false;
    gameState.mineHit = null;
    gameState.undoCount = 0;
    gameState.undoStack = [];

    updateUI();
    viewState.dirtyRender = true;
    requestRender();

    showToast('success', 'Partie import√©e', 'Le jeu a √©t√© restaur√© avec succ√®s');
  } catch (e) {
    showToast('error', 'Code invalide', 'Le code fourni est invalide ou corrompu');
  }
}

function newGame(customSeed = null) {
  gameState.seed = customSeed || generateRandomSeed();
  gameState.rng = new SeededRandom(gameState.seed);
  gameState.revealed = new Set();
  gameState.flagged = new Set();
  gameState.safeCells = new Set();
  gameState.gameOver = false;
  gameState.dead = false;
  gameState.firstClick = true;
  gameState.mineHit = null;
  gameState.undoCount = 0;
  gameState.undoStack = [];
  gameState.revealedCount = 0;

  viewState.zoom = 1.0;
  viewState.offX = viewState.W / 2 - 6 * CONFIG.BASE_CELL;
  viewState.offY = viewState.H / 2 - 6 * CONFIG.BASE_CELL;

  modalOverlay.classList.remove('show');
  updateUI();
  viewState.dirtyRender = true;
  requestRender();

  showToast('info', 'Nouveau jeu', `Seed: ${gameState.seed}`);
}

function resize() {
  const rect = canvasWrap.getBoundingClientRect();
  const newW = Math.floor(rect.width);
  const newH = Math.floor(rect.height);

  if (newW === viewState.W && newH === viewState.H) return;

  const fx = viewState.W ? viewState.offX / viewState.W : 0.5;
  const fy = viewState.H ? viewState.offY / viewState.H : 0.5;

  viewState.W = canvas.width = newW;
  viewState.H = canvas.height = newH;
  viewState.offX = fx * newW;
  viewState.offY = fy * newH;

  viewState.dirtyRender = true;
  requestRender();
}

const resizeObserver = new ResizeObserver(resize);
resizeObserver.observe(canvasWrap);

canvas.addEventListener('mousedown', e => {
  if (e.button === 1 || e.ctrlKey) {
    viewState.panning = true;
    viewState.didPan = false;
    viewState.panStartX = e.clientX;
    viewState.panStartY = e.clientY;
    viewState.panOffX0 = viewState.offX;
    viewState.panOffY0 = viewState.offY;
    canvas.classList.add('panning');
    e.preventDefault();
  }
});

canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  const [cx, cy] = screenToCell(e.clientX - rect.left, e.clientY - rect.top);
  
  if (viewState.panning) {
    const dx = e.clientX - viewState.panStartX;
    const dy = e.clientY - viewState.panStartY;
    
    if (Math.abs(dx) > 2 || Math.abs(dy) > 2) {
      viewState.didPan = true;
    }
    
    viewState.offX = viewState.panOffX0 + dx;
    viewState.offY = viewState.panOffY0 + dy;
    viewState.dirtyRender = true;
    requestRender();
  } else {
    const newHover = [cx, cy];
    const changed = !viewState.hoverCell || 
                   viewState.hoverCell[0] !== cx || 
                   viewState.hoverCell[1] !== cy;
    
    if (changed) {
      viewState.hoverCell = newHover;
      viewState.dirtyRender = true;
      requestRender();
    }
  }
});

canvas.addEventListener('mouseup', () => {
  if (viewState.panning) {
    viewState.panning = false;
    canvas.classList.remove('panning');
  }
});

canvas.addEventListener('mouseleave', () => {
  viewState.panning = false;
  canvas.classList.remove('panning');
  viewState.hoverCell = null;
  viewState.dirtyRender = true;
  requestRender();
});

canvas.addEventListener('click', e => {
  if (viewState.didPan) {
    viewState.didPan = false;
    return;
  }
  if (e.ctrlKey) return;

  const rect = canvas.getBoundingClientRect();
  const [cx, cy] = screenToCell(e.clientX - rect.left, e.clientY - rect.top);
  reveal(cx, cy);
});

canvas.addEventListener('contextmenu', e => {
  e.preventDefault();
  if (viewState.didPan) return;

  const rect = canvas.getBoundingClientRect();
  const [cx, cy] = screenToCell(e.clientX - rect.left, e.clientY - rect.top);
  toggleFlag(cx, cy);
});

canvas.addEventListener('wheel', e => {
  e.preventDefault();

  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const factor = e.deltaY < 0 ? 1.15 : 1 / 1.15;
  const newZoom = Math.min(CONFIG.ZOOM_MAX, Math.max(CONFIG.ZOOM_MIN, viewState.zoom * factor));
  const scale = newZoom / viewState.zoom;

  viewState.offX = mx - scale * (mx - viewState.offX);
  viewState.offY = my - scale * (my - viewState.offY);
  viewState.zoom = newZoom;

  viewState.hiddenTexture = null;

  viewState.dirtyRender = true;
  requestRender();
}, { passive: false });

let lastTouchDist = null;
let lastTouchCx, lastTouchCy;

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  
  if (e.touches.length === 2) {
    lastTouchDist = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY
    );
    lastTouchCx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
    lastTouchCy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
  } else if (e.touches.length === 1) {
    viewState.panning = true;
    viewState.didPan = false;
    viewState.panStartX = e.touches[0].clientX;
    viewState.panStartY = e.touches[0].clientY;
    viewState.panOffX0 = viewState.offX;
    viewState.panOffY0 = viewState.offY;
    lastTouchDist = null;
  }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  
  if (e.touches.length === 2 && lastTouchDist !== null) {
    const dist = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY
    );
    const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
    const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
    
    const rect = canvas.getBoundingClientRect();
    const mx = cx - rect.left;
    const my = cy - rect.top;
    
    const newZoom = Math.min(CONFIG.ZOOM_MAX, Math.max(CONFIG.ZOOM_MIN, 
      viewState.zoom * (dist / lastTouchDist)));
    const scale = newZoom / viewState.zoom;
    
    viewState.offX = mx - scale * (mx - viewState.offX) + (cx - lastTouchCx);
    viewState.offY = my - scale * (my - viewState.offY) + (cy - lastTouchCy);
    viewState.zoom = newZoom;
    
    lastTouchDist = dist;
    lastTouchCx = cx;
    lastTouchCy = cy;
    
    viewState.hiddenTexture = null;
    viewState.dirtyRender = true;
    requestRender();
  } else if (e.touches.length === 1 && viewState.panning) {
    const dx = e.touches[0].clientX - viewState.panStartX;
    const dy = e.touches[0].clientY - viewState.panStartY;
    
    if (Math.abs(dx) > 2 || Math.abs(dy) > 2) {
      viewState.didPan = true;
    }
    
    viewState.offX = viewState.panOffX0 + dx;
    viewState.offY = viewState.panOffY0 + dy;
    viewState.dirtyRender = true;
    requestRender();
  }
}, { passive: false });

canvas.addEventListener('touchend', e => {
  e.preventDefault();
  
  if (e.changedTouches.length === 1 && !viewState.didPan && e.touches.length === 0) {
    const touch = e.changedTouches[0];
    const rect = canvas.getBoundingClientRect();
    const [cx, cy] = screenToCell(touch.clientX - rect.left, touch.clientY - rect.top);
    
    if (gameState.mobileMode === 'reveal') {
      reveal(cx, cy);
    } else {
      toggleFlag(cx, cy);
    }
  }
  
  viewState.panning = false;
  viewState.didPan = false;
  lastTouchDist = null;
}, { passive: false });

mobileRevealBtn.addEventListener('click', () => {
  gameState.mobileMode = 'reveal';
  mobileRevealBtn.classList.add('active');
  mobileFlagBtn.classList.remove('active');
});

mobileFlagBtn.addEventListener('click', () => {
  gameState.mobileMode = 'flag';
  mobileFlagBtn.classList.add('active');
  mobileRevealBtn.classList.remove('active');
});

document.addEventListener('keydown', e => {
  if (e.ctrlKey && e.key === 'z') {
    e.preventDefault();
    undo();
  }
  if (e.ctrlKey && e.key === 'r') {
    e.preventDefault();
    confirmNewGame();
  }
  if (e.ctrlKey && e.key === 's') {
    e.preventDefault();
    saveGame(true);
  }
});

newGameBtn.addEventListener('click', confirmNewGame);
undoBtn.addEventListener('click', undo);
saveBtn.addEventListener('click', () => saveGame(true));
exportBtn.addEventListener('click', exportGame);

applySeedBtn.addEventListener('click', () => {
  const seed = seedInputEl.value.trim();
  if (seed) {
    newGame(seed);
  } else {
    newGame();
  }
});

importBtn.addEventListener('click', () => {
  const code = importInputEl.value.trim();
  if (code) {
    importGame(code);
    importInputEl.value = '';
  }
});

sidebarToggleBtn.addEventListener('click', () => {
  sidebar.classList.toggle('collapsed');
  sidebarToggleIcon.textContent = sidebar.classList.contains('collapsed') ? '‚ñ∂' : '‚óÄ';
});

sidebarToggleMobile.addEventListener('click', () => {
  sidebar.classList.toggle('show');
});

document.addEventListener('click', e => {
  if (window.innerWidth <= 768 && sidebar.classList.contains('show')) {
    if (!sidebar.contains(e.target) && e.target !== sidebarToggleMobile) {
      sidebar.classList.remove('show');
    }
  }
});

modalOverlay.addEventListener('click', e => {
  if (e.target === modalOverlay) {
    modalOverlay.classList.remove('show');
  }
});

setInterval(() => {
  if (gameState.revealedCount > 0 && !gameState.gameOver) {
    saveGame(false);
  }
}, CONFIG.AUTO_SAVE_INTERVAL);

window.addEventListener('load', () => {
  const rect = canvasWrap.getBoundingClientRect();
  viewState.W = canvas.width = Math.floor(rect.width);
  viewState.H = canvas.height = Math.floor(rect.height);

  initBackground();

  if (!loadGame()) {
    newGame();
  }

  viewState.dirtyRender = true;
  requestRender();

  window.addEventListener('resize', () => {
    bgCanvas.width = window.innerWidth;
    bgCanvas.height = window.innerHeight;
  });
});

</script>
</body>
</html>
