<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DÃ©mineur Infini â€¢ Moderne</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

*, *::before, *::after {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

:root {
  --bg-main: #0a0e1a;
  --bg-panel: rgba(20, 25, 40, 0.7);
  --bg-card: rgba(30, 35, 50, 0.8);
  --accent-primary: #00d4ff;
  --accent-secondary: #ff006e;
  --accent-success: #00ff88;
  --accent-warning: #ffaa00;
  --text-primary: #ffffff;
  --text-secondary: #a0aec0;
  --border-color: rgba(255, 255, 255, 0.1);
  --shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
  --glow: 0 0 20px rgba(0, 212, 255, 0.3);
}

html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: var(--bg-main);
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  color: var(--text-primary);
}

/* Animated background */
#bg-canvas {
  position: fixed;
  inset: 0;
  z-index: 0;
  opacity: 0.3;
}

#app {
  position: fixed;
  inset: 0;
  display: flex;
  flex-direction: column;
  z-index: 1;
}

/* Header */
#header {
  flex: 0 0 auto;
  backdrop-filter: blur(20px);
  background: var(--bg-panel);
  border-bottom: 1px solid var(--border-color);
  padding: 16px 24px;
  display: flex;
  align-items: center;
  gap: 24px;
  box-shadow: var(--shadow);
}

#logo {
  display: flex;
  align-items: center;
  gap: 12px;
  font-size: 20px;
  font-weight: 700;
  letter-spacing: -0.5px;
}

#logo-icon {
  font-size: 28px;
  filter: drop-shadow(0 0 8px var(--accent-primary));
}

.header-stats {
  display: flex;
  gap: 20px;
  margin-left: auto;
}

.stat-card {
  backdrop-filter: blur(10px);
  background: var(--bg-card);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 8px 16px;
  display: flex;
  flex-direction: column;
  gap: 2px;
  min-width: 100px;
  transition: all 0.3s ease;
}

.stat-card:hover {
  transform: translateY(-2px);
  box-shadow: var(--glow);
}

.stat-label {
  font-size: 11px;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
}

.stat-value {
  font-size: 24px;
  font-weight: 700;
  font-variant-numeric: tabular-nums;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.btn-group {
  display: flex;
  gap: 8px;
}

.btn {
  backdrop-filter: blur(10px);
  background: var(--bg-card);
  border: 1px solid var(--border-color);
  border-radius: 10px;
  padding: 10px 18px;
  font-family: inherit;
  font-size: 14px;
  font-weight: 600;
  color: var(--text-primary);
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  gap: 8px;
  white-space: nowrap;
}

.btn:hover {
  background: rgba(50, 55, 70, 0.9);
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(0, 212, 255, 0.2);
}

.btn:active {
  transform: translateY(0);
}

.btn-primary {
  background: linear-gradient(135deg, var(--accent-primary), #0099cc);
  border: none;
  box-shadow: 0 4px 16px rgba(0, 212, 255, 0.3);
}

.btn-primary:hover {
  box-shadow: 0 6px 20px rgba(0, 212, 255, 0.4);
  transform: translateY(-2px);
}

.btn-icon {
  font-size: 18px;
}

/* Main game area */
#game-container {
  flex: 1 1 0;
  display: flex;
  min-height: 0;
  position: relative;
}

#canvas-wrap {
  flex: 1 1 0;
  position: relative;
  overflow: hidden;
  cursor: crosshair;
}

#canvas {
  display: block;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
}

#canvas.panning {
  cursor: grab;
}

/* Sidebar */
#sidebar {
  flex: 0 0 auto;
  width: 320px;
  backdrop-filter: blur(20px);
  background: var(--bg-panel);
  border-left: 1px solid var(--border-color);
  padding: 24px;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.panel {
  backdrop-filter: blur(10px);
  background: var(--bg-card);
  border: 1px solid var(--border-color);
  border-radius: 16px;
  padding: 20px;
}

.panel-title {
  font-size: 14px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 16px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.input-group {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-bottom: 12px;
}

.input-group label {
  font-size: 13px;
  font-weight: 500;
  color: var(--text-secondary);
}

.input-group input {
  backdrop-filter: blur(10px);
  background: rgba(10, 14, 26, 0.6);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 10px 12px;
  font-family: 'Courier New', monospace;
  font-size: 14px;
  color: var(--text-primary);
  transition: all 0.2s ease;
}

.input-group input:focus {
  outline: none;
  border-color: var(--accent-primary);
  box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.1);
}

.input-group input::placeholder {
  color: var(--text-secondary);
  opacity: 0.5;
}

.btn-small {
  padding: 8px 14px;
  font-size: 13px;
}

.help-text {
  font-size: 12px;
  color: var(--text-secondary);
  line-height: 1.5;
  margin-top: 8px;
}

.shortcut-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.shortcut-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: rgba(10, 14, 26, 0.4);
  border-radius: 8px;
  font-size: 12px;
}

.shortcut-key {
  background: rgba(255, 255, 255, 0.1);
  padding: 4px 8px;
  border-radius: 4px;
  font-family: 'Courier New', monospace;
  font-size: 11px;
  font-weight: 600;
}

/* Game over modal */
#modal-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(8px);
  z-index: 100;
  align-items: center;
  justify-content: center;
  animation: fadeIn 0.3s ease;
}

#modal-overlay.show {
  display: flex;
}

.modal {
  backdrop-filter: blur(20px);
  background: var(--bg-card);
  border: 1px solid var(--border-color);
  border-radius: 24px;
  padding: 40px;
  max-width: 500px;
  text-align: center;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
  animation: slideUp 0.3s ease;
}

.modal-icon {
  font-size: 72px;
  margin-bottom: 20px;
  filter: drop-shadow(0 0 20px currentColor);
}

.modal-title {
  font-size: 32px;
  font-weight: 700;
  margin-bottom: 12px;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.modal-text {
  font-size: 16px;
  color: var(--text-secondary);
  margin-bottom: 30px;
}

.modal-actions {
  display: flex;
  gap: 12px;
  justify-content: center;
}

/* Toast notifications */
#toast-container {
  position: fixed;
  top: 80px;
  right: 24px;
  z-index: 200;
  display: flex;
  flex-direction: column;
  gap: 12px;
  pointer-events: none;
}

.toast {
  backdrop-filter: blur(20px);
  background: var(--bg-card);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 16px 20px;
  display: flex;
  align-items: center;
  gap: 12px;
  box-shadow: var(--shadow);
  animation: slideInRight 0.3s ease;
  pointer-events: all;
  min-width: 280px;
}

.toast-icon {
  font-size: 24px;
}

.toast-content {
  flex: 1;
}

.toast-title {
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 2px;
}

.toast-message {
  font-size: 12px;
  color: var(--text-secondary);
}

.toast.success .toast-icon {
  color: var(--accent-success);
}

.toast.error .toast-icon {
  color: var(--accent-secondary);
}

.toast.info .toast-icon {
  color: var(--accent-primary);
}

/* Animations */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideInRight {
  from {
    opacity: 0;
    transform: translateX(100%);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

/* Mobile responsive */
@media (max-width: 768px) {
  #header {
    flex-wrap: wrap;
    padding: 12px 16px;
    gap: 12px;
  }

  .header-stats {
    order: 3;
    width: 100%;
    justify-content: space-between;
  }

  #sidebar {
    position: fixed;
    right: -100%;
    top: 0;
    height: 100%;
    z-index: 50;
    transition: right 0.3s ease;
  }

  #sidebar.show {
    right: 0;
  }

  .btn-group {
    flex-wrap: wrap;
  }
}

/* Loading spinner */
.spinner {
  display: inline-block;
  width: 16px;
  height: 16px;
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-top-color: var(--accent-primary);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* Scrollbar */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.2);
}

::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.2);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.3);
}
</style>
</head>
<body>

<!-- Animated background -->
<canvas id="bg-canvas"></canvas>

<!-- Toast container -->
<div id="toast-container"></div>

<!-- Modal -->
<div id="modal-overlay">
  <div class="modal">
    <div class="modal-icon" id="modal-icon">ğŸ’¥</div>
    <div class="modal-title" id="modal-title">Boom!</div>
    <div class="modal-text" id="modal-text">Vous avez touchÃ© une mine</div>
    <div class="modal-actions">
      <button class="btn btn-primary" id="modal-undo">
        <span class="btn-icon">â†©</span>
        Annuler
      </button>
      <button class="btn" id="modal-new">
        <span class="btn-icon">ğŸ”„</span>
        Nouveau jeu
      </button>
    </div>
  </div>
</div>

<!-- Main app -->
<div id="app">
  
  <!-- Header -->
  <div id="header">
    <div id="logo">
      <span id="logo-icon">ğŸ’</span>
      <span>DÃ©mineur Infini</span>
    </div>

    <div class="btn-group">
      <button class="btn btn-primary" id="new-game-btn" title="Ctrl+R">
        <span class="btn-icon">ğŸ”„</span>
        Nouveau
      </button>
      <button class="btn" id="undo-btn" title="Ctrl+Z">
        <span class="btn-icon">â†©</span>
        Annuler
      </button>
      <button class="btn" id="save-btn" title="Ctrl+S">
        <span class="btn-icon">ğŸ’¾</span>
        Sauvegarder
      </button>
      <button class="btn" id="export-btn" title="Exporter">
        <span class="btn-icon">ğŸ“‹</span>
        Copier
      </button>
      <button class="btn" id="sidebar-toggle" style="display: none;">
        <span class="btn-icon">âš™ï¸</span>
      </button>
    </div>

    <div class="header-stats">
      <div class="stat-card">
        <div class="stat-label">ğŸš© Drapeaux</div>
        <div class="stat-value" id="flag-count">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">â†© Retours</div>
        <div class="stat-value" id="undo-count">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">ğŸ“ Cases</div>
        <div class="stat-value" id="revealed-count">0</div>
      </div>
    </div>
  </div>

  <!-- Game container -->
  <div id="game-container">
    <div id="canvas-wrap">
      <canvas id="canvas"></canvas>
    </div>

    <!-- Sidebar -->
    <div id="sidebar">
      <div class="panel">
        <div class="panel-title">
          <span>ğŸ²</span>
          <span>Seed & GÃ©nÃ©ration</span>
        </div>
        
        <div class="input-group">
          <label for="seed-input">Seed (laisser vide pour alÃ©atoire)</label>
          <input type="text" id="seed-input" placeholder="Ex: minecraft123">
        </div>

        <button class="btn btn-small" id="apply-seed-btn" style="width: 100%;">
          <span class="btn-icon">âœ¨</span>
          Appliquer seed
        </button>

        <div class="help-text">
          La seed permet de gÃ©nÃ©rer toujours la mÃªme carte. Partagez-la avec vos amis!
        </div>

        <div class="input-group" style="margin-top: 16px;">
          <label>Seed actuelle</label>
          <input type="text" id="current-seed" readonly style="opacity: 0.7;">
        </div>
      </div>

      <div class="panel">
        <div class="panel-title">
          <span>ğŸ’¾</span>
          <span>Import / Export</span>
        </div>

        <div class="input-group">
          <label for="import-input">Coller un code de partie</label>
          <input type="text" id="import-input" placeholder="Collez le code ici...">
        </div>

        <button class="btn btn-small" id="import-btn" style="width: 100%;">
          <span class="btn-icon">ğŸ“¥</span>
          Importer partie
        </button>

        <div class="help-text">
          Le code contient la seed, les cases rÃ©vÃ©lÃ©es et les drapeaux.
        </div>
      </div>

      <div class="panel">
        <div class="panel-title">
          <span>âŒ¨ï¸</span>
          <span>Raccourcis</span>
        </div>

        <div class="shortcut-list">
          <div class="shortcut-item">
            <span>RÃ©vÃ©ler case</span>
            <span class="shortcut-key">Clic gauche</span>
          </div>
          <div class="shortcut-item">
            <span>Placer drapeau</span>
            <span class="shortcut-key">Clic droit</span>
          </div>
          <div class="shortcut-item">
            <span>DÃ©placer vue</span>
            <span class="shortcut-key">Ctrl + Glisser</span>
          </div>
          <div class="shortcut-item">
            <span>Zoom</span>
            <span class="shortcut-key">Molette</span>
          </div>
          <div class="shortcut-item">
            <span>Annuler</span>
            <span class="shortcut-key">Ctrl + Z</span>
          </div>
          <div class="shortcut-item">
            <span>Nouveau jeu</span>
            <span class="shortcut-key">Ctrl + R</span>
          </div>
          <div class="shortcut-item">
            <span>Sauvegarder</span>
            <span class="shortcut-key">Ctrl + S</span>
          </div>
        </div>
      </div>

      <div class="help-text" style="padding: 16px; background: rgba(0, 212, 255, 0.1); border-radius: 12px; border: 1px solid rgba(0, 212, 255, 0.2);">
        ğŸ’¡ <strong>Astuce :</strong> Quand vous rÃ©vÃ©lez une case avec 1 mine adjacente, toutes les cases autour sont automatiquement rÃ©vÃ©lÃ©es pour accÃ©lÃ©rer le jeu!
      </div>
    </div>
  </div>

</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONFIGURATION & CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const CONFIG = {
  BASE_CELL: 24,           // Cell size in pixels
  MINE_PCT: 18,            // Percentage of mines
  SAFE_RADIUS: 4,          // Safe zone radius on first click
  MAX_FLOOD: 30000,        // BFS limit
  MAX_UNDO: 100,           // Max undo steps
  ZOOM_MIN: 0.2,
  ZOOM_MAX: 5,
  AUTO_SAVE_INTERVAL: 5000, // Auto-save every 5s
  RENDER_CULLING: 2,       // Extra cells to render outside viewport
};

const COLORS = {
  numbers: [
    null,
    '#0066ff',  // 1 - blue
    '#00aa44',  // 2 - green
    '#ff3344',  // 3 - red
    '#0033aa',  // 4 - dark blue
    '#aa1100',  // 5 - dark red
    '#00aaaa',  // 6 - cyan
    '#222222',  // 7 - black
    '#888888',  // 8 - gray
  ],
  cell: {
    revealed: '#2a3142',
    hidden: '#3d4663',
    hiddenHover: '#4a5270',
    border: '#1a1e2e',
    borderLight: '#5a607d',
  },
  mine: '#ff0044',
  flag: '#ffaa00',
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DOM ELEMENTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
const bgCanvas = document.getElementById('bg-canvas');
const bgCtx = bgCanvas.getContext('2d');

const flagCountEl = document.getElementById('flag-count');
const undoCountEl = document.getElementById('undo-count');
const revealedCountEl = document.getElementById('revealed-count');
const currentSeedEl = document.getElementById('current-seed');
const seedInputEl = document.getElementById('seed-input');
const importInputEl = document.getElementById('import-input');

const newGameBtn = document.getElementById('new-game-btn');
const undoBtn = document.getElementById('undo-btn');
const saveBtn = document.getElementById('save-btn');
const exportBtn = document.getElementById('export-btn');
const applySeedBtn = document.getElementById('apply-seed-btn');
const importBtn = document.getElementById('import-btn');
const sidebarToggle = document.getElementById('sidebar-toggle');
const sidebar = document.getElementById('sidebar');

const modalOverlay = document.getElementById('modal-overlay');
const modalIcon = document.getElementById('modal-icon');
const modalTitle = document.getElementById('modal-title');
const modalText = document.getElementById('modal-text');
const modalUndo = document.getElementById('modal-undo');
const modalNew = document.getElementById('modal-new');

const canvasWrap = document.getElementById('canvas-wrap');
const toastContainer = document.getElementById('toast-container');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GAME STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let gameState = {
  seed: '',
  rng: null,
  revealed: new Set(),
  flagged: new Set(),
  safeCells: new Set(),
  gameOver: false,
  dead: false,
  firstClick: true,
  mineHit: null,
  undoCount: 0,
  undoStack: [],
  revealedCount: 0,
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VIEW STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let viewState = {
  W: 0,
  H: 0,
  offX: 0,
  offY: 0,
  zoom: 1.0,
  panning: false,
  panStartX: 0,
  panStartY: 0,
  panOffX0: 0,
  panOffY0: 0,
  didPan: false,
  hoverCell: null,
  dirtyRender: true,
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SEEDED RANDOM NUMBER GENERATOR (Mulberry32)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SeededRandom {
  constructor(seed) {
    this.state = this.hashString(seed);
  }

  hashString(str) {
    let h = 0;
    for (let i = 0; i < str.length; i++) {
      h = Math.imul(31, h) + str.charCodeAt(i) | 0;
    }
    return h >>> 0;
  }

  next() {
    let t = this.state += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }

  nextInt(min, max) {
    return Math.floor(this.next() * (max - min + 1)) + min;
  }

  hashXY(x, y) {
    let h = Math.imul(x | 0, 0x9e3779b9) ^ Math.imul(y | 0, 0x6c62272e);
    h ^= this.state;
    h ^= h >>> 16;
    h = Math.imul(h, 0x45d9f3b);
    h ^= h >>> 16;
    return (h >>> 0) % 100;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MINE GENERATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function hasMine(x, y) {
  const k = key(x, y);
  if (gameState.safeCells.has(k)) return false;
  return gameState.rng.hashXY(x, y) < CONFIG.MINE_PCT;
}

function countMines(x, y) {
  let count = 0;
  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      if (dx === 0 && dy === 0) continue;
      if (hasMine(x + dx, y + dy)) count++;
    }
  }
  return count;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPER FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const key = (x, y) => `${x},${y}`;
const parseKey = (k) => k.split(',').map(Number);
const cellSize = () => CONFIG.BASE_CELL * viewState.zoom;

function screenToCell(sx, sy) {
  const c = cellSize();
  return [
    Math.floor((sx - viewState.offX) / c),
    Math.floor((sy - viewState.offY) / c)
  ];
}

function cellToScreen(cx, cy) {
  const c = cellSize();
  return [
    cx * c + viewState.offX,
    cy * c + viewState.offY
  ];
}

function generateRandomSeed() {
  const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
  let seed = '';
  for (let i = 0; i < 12; i++) {
    seed += chars[Math.floor(Math.random() * chars.length)];
  }
  return seed;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UNDO SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function snapshot() {
  gameState.undoStack.push({
    revealed: new Set(gameState.revealed),
    flagged: new Set(gameState.flagged),
    safeCells: new Set(gameState.safeCells),
    gameOver: gameState.gameOver,
    dead: gameState.dead,
    firstClick: gameState.firstClick,
    mineHit: gameState.mineHit,
    revealedCount: gameState.revealedCount,
  });
  
  if (gameState.undoStack.length > CONFIG.MAX_UNDO) {
    gameState.undoStack.shift();
  }
}

function undo() {
  if (gameState.undoStack.length === 0) {
    showToast('info', 'Impossible d\'annuler', 'Aucune action Ã  annuler');
    return;
  }

  const snap = gameState.undoStack.pop();
  gameState.revealed = snap.revealed;
  gameState.flagged = snap.flagged;
  gameState.safeCells = snap.safeCells;
  gameState.gameOver = snap.gameOver;
  gameState.dead = snap.dead;
  gameState.firstClick = snap.firstClick;
  gameState.mineHit = snap.mineHit;
  gameState.revealedCount = snap.revealedCount;
  gameState.undoCount++;

  if (gameState.gameOver) {
    modalOverlay.classList.remove('show');
  }

  updateUI();
  viewState.dirtyRender = true;
  requestRender();

  showToast('success', 'Action annulÃ©e', 'Retour en arriÃ¨re effectuÃ©');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SAFE ZONE (First click)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function buildSafeZone(ox, oy) {
  gameState.safeCells.clear();
  for (let dy = -CONFIG.SAFE_RADIUS; dy <= CONFIG.SAFE_RADIUS; dy++) {
    for (let dx = -CONFIG.SAFE_RADIUS; dx <= CONFIG.SAFE_RADIUS; dx++) {
      gameState.safeCells.add(key(ox + dx, oy + dy));
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CORE GAME ACTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function reveal(x, y) {
  if (gameState.gameOver) return;

  const k = key(x, y);
  if (gameState.revealed.has(k) || gameState.flagged.has(k)) return;

  // First click: create safe zone
  if (gameState.firstClick) {
    snapshot();
    buildSafeZone(x, y);
    gameState.firstClick = false;
  } else {
    snapshot();
  }

  // Hit a mine
  if (hasMine(x, y)) {
    gameState.revealed.add(k);
    gameState.revealedCount++;
    gameState.dead = true;
    gameState.gameOver = true;
    gameState.mineHit = [x, y];

    showGameOverModal();
    updateUI();
    viewState.dirtyRender = true;
    requestRender();
    return;
  }

  // BFS flood fill
  const queue = [[x, y]];
  const seen = new Set([k]);
  let count = 0;

  while (queue.length > 0 && count < CONFIG.MAX_FLOOD) {
    const [cx, cy] = queue.shift();
    const ck = key(cx, cy);

    if (!gameState.revealed.has(ck)) {
      gameState.revealed.add(ck);
      gameState.revealedCount++;
      count++;
    }

    const mineCount = countMines(cx, cy);

    // Auto-reveal neighbors for cells with 1 adjacent mine
    if (mineCount === 1) {
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = cx + dx;
          const ny = cy + dy;
          const nk = key(nx, ny);
          
          if (!gameState.revealed.has(nk) && !gameState.flagged.has(nk) && !hasMine(nx, ny)) {
            if (!seen.has(nk)) {
              seen.add(nk);
              queue.push([nx, ny]);
            }
          }
        }
      }
    }
    // Propagate through empty cells (0 adjacent mines)
    else if (mineCount === 0) {
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = cx + dx;
          const ny = cy + dy;
          const nk = key(nx, ny);
          
          if (!seen.has(nk) && !hasMine(nx, ny) && !gameState.flagged.has(nk)) {
            seen.add(nk);
            queue.push([nx, ny]);
          }
        }
      }
    }
  }

  updateUI();
  viewState.dirtyRender = true;
  requestRender();
}

function toggleFlag(x, y) {
  if (gameState.gameOver) return;

  const k = key(x, y);
  if (gameState.revealed.has(k)) return;

  snapshot();

  if (gameState.flagged.has(k)) {
    gameState.flagged.delete(k);
  } else {
    gameState.flagged.add(k);
  }

  updateUI();
  viewState.dirtyRender = true;
  requestRender();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RENDERING (Optimized with culling)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let renderQueued = false;

function requestRender() {
  if (!renderQueued) {
    renderQueued = true;
    requestAnimationFrame(() => {
      render();
      renderQueued = false;
    });
  }
}

function render() {
  if (!viewState.dirtyRender) return;

  const c = cellSize();
  const { W, H, offX, offY } = viewState;

  // Clear canvas
  ctx.fillStyle = COLORS.cell.border;
  ctx.fillRect(0, 0, W, H);

  // Calculate visible cell range with culling margin
  const margin = CONFIG.RENDER_CULLING;
  const x0 = Math.floor(-offX / c) - margin;
  const y0 = Math.floor(-offY / c) - margin;
  const x1 = Math.ceil((W - offX) / c) + margin;
  const y1 = Math.ceil((H - offY) / c) + margin;

  // Batch rendering for better performance
  for (let cy = y0; cy <= y1; cy++) {
    for (let cx = x0; cx <= x1; cx++) {
      drawCell(cx, cy, c);
    }
  }

  // Draw hover highlight
  if (viewState.hoverCell && !gameState.gameOver) {
    const [hx, hy] = viewState.hoverCell;
    const [sx, sy] = cellToScreen(hx, hy);
    ctx.strokeStyle = 'rgba(0, 212, 255, 0.5)';
    ctx.lineWidth = 2;
    ctx.strokeRect(sx, sy, c, c);
  }

  viewState.dirtyRender = false;
}

function drawCell(cx, cy, c) {
  const k = key(cx, cy);
  const [sx, sy] = cellToScreen(cx, cy);

  // Skip if completely outside viewport
  if (sx + c < 0 || sx > viewState.W || sy + c < 0 || sy > viewState.H) {
    return;
  }

  const isRevealed = gameState.revealed.has(k);
  const isFlagged = gameState.flagged.has(k);
  const isMine = hasMine(cx, cy);
  const isHitMine = gameState.mineHit && gameState.mineHit[0] === cx && gameState.mineHit[1] === cy;

  if (isRevealed) {
    drawRevealedCell(sx, sy, c, isMine, isHitMine, cx, cy);
  } else {
    drawHiddenCell(sx, sy, c, isFlagged);
  }
}

function drawHiddenCell(sx, sy, c, isFlagged) {
  const padding = 1;

  // Cell background
  ctx.fillStyle = COLORS.cell.hidden;
  ctx.fillRect(sx + padding, sy + padding, c - padding * 2, c - padding * 2);

  // 3D effect - top and left highlights
  ctx.fillStyle = COLORS.cell.borderLight;
  ctx.fillRect(sx + padding, sy + padding, c - padding * 2, 2);
  ctx.fillRect(sx + padding, sy + padding, 2, c - padding * 2);

  // Flag
  if (isFlagged) {
    drawFlag(sx, sy, c);
  }
}

function drawRevealedCell(sx, sy, c, isMine, isHitMine, cx, cy) {
  const padding = 1;

  // Background color
  ctx.fillStyle = isHitMine ? COLORS.mine : COLORS.cell.revealed;
  ctx.fillRect(sx + padding, sy + padding, c - padding * 2, c - padding * 2);

  // Content
  if (isMine) {
    drawMine(sx, sy, c, isHitMine);
  } else {
    const count = countMines(cx, cy);
    if (count > 0) {
      drawNumber(sx, sy, c, count);
    }
  }
}

function drawFlag(sx, sy, c) {
  const centerX = sx + c / 2;
  const centerY = sy + c / 2;
  const size = c * 0.4;

  // Flag pole
  ctx.fillStyle = '#333';
  ctx.fillRect(centerX - 1, centerY - size * 0.8, 2, size * 1.6);

  // Flag
  ctx.fillStyle = COLORS.flag;
  ctx.beginPath();
  ctx.moveTo(centerX, centerY - size * 0.8);
  ctx.lineTo(centerX + size * 0.8, centerY - size * 0.3);
  ctx.lineTo(centerX, centerY + size * 0.2);
  ctx.closePath();
  ctx.fill();

  // Flag shadow
  ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
  ctx.beginPath();
  ctx.moveTo(centerX, centerY - size * 0.7);
  ctx.lineTo(centerX + size * 0.6, centerY - size * 0.3);
  ctx.lineTo(centerX, centerY + size * 0.1);
  ctx.closePath();
  ctx.fill();
}

function drawMine(sx, sy, c, isHit) {
  const centerX = sx + c / 2;
  const centerY = sy + c / 2;
  const radius = c * 0.25;

  // Mine body
  ctx.fillStyle = isHit ? '#ff0000' : '#222';
  ctx.beginPath();
  ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
  ctx.fill();

  // Mine spikes
  ctx.strokeStyle = isHit ? '#ff0000' : '#222';
  ctx.lineWidth = Math.max(1, c * 0.08);
  const spikeLength = radius * 1.5;

  for (let i = 0; i < 8; i++) {
    const angle = (i * Math.PI) / 4;
    const x1 = centerX + Math.cos(angle) * radius;
    const y1 = centerY + Math.sin(angle) * radius;
    const x2 = centerX + Math.cos(angle) * spikeLength;
    const y2 = centerY + Math.sin(angle) * spikeLength;
    
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }

  // Highlight
  if (!isHit) {
    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
    ctx.beginPath();
    ctx.arc(centerX - radius * 0.3, centerY - radius * 0.3, radius * 0.3, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawNumber(sx, sy, c, count) {
  ctx.fillStyle = COLORS.numbers[count] || '#000';
  ctx.font = `bold ${Math.floor(c * 0.6)}px Inter, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(count, sx + c / 2, sy + c / 2);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BACKGROUND ANIMATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let bgParticles = [];

function initBackground() {
  bgCanvas.width = window.innerWidth;
  bgCanvas.height = window.innerHeight;

  bgParticles = [];
  for (let i = 0; i < 50; i++) {
    bgParticles.push({
      x: Math.random() * bgCanvas.width,
      y: Math.random() * bgCanvas.height,
      vx: (Math.random() - 0.5) * 0.5,
      vy: (Math.random() - 0.5) * 0.5,
      size: Math.random() * 2 + 1,
    });
  }

  animateBackground();
}

function animateBackground() {
  bgCtx.fillStyle = 'rgba(10, 14, 26, 0.1)';
  bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);

  bgParticles.forEach(p => {
    p.x += p.vx;
    p.y += p.vy;

    if (p.x < 0 || p.x > bgCanvas.width) p.vx *= -1;
    if (p.y < 0 || p.y > bgCanvas.height) p.vy *= -1;

    bgCtx.fillStyle = 'rgba(0, 212, 255, 0.3)';
    bgCtx.beginPath();
    bgCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    bgCtx.fill();
  });

  requestAnimationFrame(animateBackground);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UI UPDATES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function updateUI() {
  flagCountEl.textContent = gameState.flagged.size;
  undoCountEl.textContent = gameState.undoCount;
  revealedCountEl.textContent = gameState.revealedCount;
  currentSeedEl.value = gameState.seed;
}

function showGameOverModal() {
  modalIcon.textContent = 'ğŸ’¥';
  modalTitle.textContent = 'Boom!';
  modalText.textContent = 'Vous avez touchÃ© une mine. Utilisez "Annuler" pour revenir en arriÃ¨re.';
  modalOverlay.classList.add('show');
}

function showToast(type, title, message) {
  const toast = document.createElement('div');
  toast.className = `toast ${type}`;
  
  const icons = {
    success: 'âœ…',
    error: 'âŒ',
    info: 'â„¹ï¸',
  };

  toast.innerHTML = `
    <div class="toast-icon">${icons[type]}</div>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      <div class="toast-message">${message}</div>
    </div>
  `;

  toastContainer.appendChild(toast);

  setTimeout(() => {
    toast.style.animation = 'slideInRight 0.3s ease reverse';
    setTimeout(() => toast.remove(), 300);
  }, 3000);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SAVE / LOAD SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function saveGame() {
  const saveData = {
    seed: gameState.seed,
    revealed: Array.from(gameState.revealed),
    flagged: Array.from(gameState.flagged),
    safeCells: Array.from(gameState.safeCells),
    firstClick: gameState.firstClick,
    revealedCount: gameState.revealedCount,
    undoCount: gameState.undoCount,
    timestamp: Date.now(),
  };

  try {
    localStorage.setItem('minesweeper_save', JSON.stringify(saveData));
    showToast('success', 'Partie sauvegardÃ©e', 'Votre progression a Ã©tÃ© enregistrÃ©e');
  } catch (e) {
    showToast('error', 'Erreur', 'Impossible de sauvegarder la partie');
  }
}

function loadGame() {
  try {
    const data = localStorage.getItem('minesweeper_save');
    if (!data) return false;

    const saveData = JSON.parse(data);
    
    gameState.seed = saveData.seed;
    gameState.rng = new SeededRandom(gameState.seed);
    gameState.revealed = new Set(saveData.revealed);
    gameState.flagged = new Set(saveData.flagged);
    gameState.safeCells = new Set(saveData.safeCells);
    gameState.firstClick = saveData.firstClick;
    gameState.revealedCount = saveData.revealedCount || saveData.revealed.length;
    gameState.undoCount = saveData.undoCount || 0;
    gameState.gameOver = false;
    gameState.dead = false;
    gameState.mineHit = null;
    gameState.undoStack = [];

    updateUI();
    viewState.dirtyRender = true;
    requestRender();

    showToast('success', 'Partie chargÃ©e', 'Votre progression a Ã©tÃ© restaurÃ©e');
    return true;
  } catch (e) {
    console.error('Load error:', e);
    return false;
  }
}

function exportGame() {
  const exportData = {
    v: 1, // version
    s: gameState.seed,
    r: Array.from(gameState.revealed),
    f: Array.from(gameState.flagged),
  };

  const encoded = btoa(JSON.stringify(exportData));
  
  navigator.clipboard.writeText(encoded).then(() => {
    showToast('success', 'Code copiÃ©!', 'Le code de partie a Ã©tÃ© copiÃ© dans votre presse-papier');
  }).catch(() => {
    showToast('error', 'Erreur', 'Impossible de copier le code');
  });
}

function importGame(code) {
  try {
    const decoded = JSON.parse(atob(code));
    
    if (decoded.v !== 1) {
      showToast('error', 'Version incompatible', 'Ce code n\'est pas compatible');
      return;
    }

    gameState.seed = decoded.s;
    gameState.rng = new SeededRandom(gameState.seed);
    gameState.revealed = new Set(decoded.r);
    gameState.flagged = new Set(decoded.f);
    gameState.safeCells = new Set();
    gameState.firstClick = false;
    gameState.revealedCount = decoded.r.length;
    gameState.gameOver = false;
    gameState.dead = false;
    gameState.mineHit = null;
    gameState.undoCount = 0;
    gameState.undoStack = [];

    updateUI();
    viewState.dirtyRender = true;
    requestRender();

    showToast('success', 'Partie importÃ©e', 'Le jeu a Ã©tÃ© restaurÃ© avec succÃ¨s');
  } catch (e) {
    showToast('error', 'Code invalide', 'Le code fourni est invalide ou corrompu');
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GAME INITIALIZATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function newGame(customSeed = null) {
  gameState.seed = customSeed || generateRandomSeed();
  gameState.rng = new SeededRandom(gameState.seed);
  gameState.revealed = new Set();
  gameState.flagged = new Set();
  gameState.safeCells = new Set();
  gameState.gameOver = false;
  gameState.dead = false;
  gameState.firstClick = true;
  gameState.mineHit = null;
  gameState.undoCount = 0;
  gameState.undoStack = [];
  gameState.revealedCount = 0;

  viewState.zoom = 1.0;
  viewState.offX = viewState.W / 2 - 6 * CONFIG.BASE_CELL;
  viewState.offY = viewState.H / 2 - 6 * CONFIG.BASE_CELL;

  modalOverlay.classList.remove('show');
  updateUI();
  viewState.dirtyRender = true;
  requestRender();

  showToast('info', 'Nouveau jeu', `Seed: ${gameState.seed}`);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RESIZE HANDLER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function resize() {
  const rect = canvasWrap.getBoundingClientRect();
  const newW = Math.floor(rect.width);
  const newH = Math.floor(rect.height);

  if (newW === viewState.W && newH === viewState.H) return;

  // Keep center
  const fx = viewState.W ? viewState.offX / viewState.W : 0.5;
  const fy = viewState.H ? viewState.offY / viewState.H : 0.5;

  viewState.W = canvas.width = newW;
  viewState.H = canvas.height = newH;
  viewState.offX = fx * newW;
  viewState.offY = fy * newH;

  viewState.dirtyRender = true;
  requestRender();
}

const resizeObserver = new ResizeObserver(resize);
resizeObserver.observe(canvasWrap);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EVENT HANDLERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Mouse events
canvas.addEventListener('mousedown', e => {
  if (e.button === 1 || e.ctrlKey) {
    viewState.panning = true;
    viewState.didPan = false;
    viewState.panStartX = e.clientX;
    viewState.panStartY = e.clientY;
    viewState.panOffX0 = viewState.offX;
    viewState.panOffY0 = viewState.offY;
    canvas.classList.add('panning');
    e.preventDefault();
  }
});

canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  const [cx, cy] = screenToCell(e.clientX - rect.left, e.clientY - rect.top);
  
  if (viewState.panning) {
    const dx = e.clientX - viewState.panStartX;
    const dy = e.clientY - viewState.panStartY;
    
    if (Math.abs(dx) > 2 || Math.abs(dy) > 2) {
      viewState.didPan = true;
    }
    
    viewState.offX = viewState.panOffX0 + dx;
    viewState.offY = viewState.panOffY0 + dy;
    viewState.dirtyRender = true;
    requestRender();
  } else {
    const newHover = [cx, cy];
    const changed = !viewState.hoverCell || 
                   viewState.hoverCell[0] !== cx || 
                   viewState.hoverCell[1] !== cy;
    
    if (changed) {
      viewState.hoverCell = newHover;
      viewState.dirtyRender = true;
      requestRender();
    }
  }
});

canvas.addEventListener('mouseup', e => {
  if (viewState.panning) {
    viewState.panning = false;
    canvas.classList.remove('panning');
  }
});

canvas.addEventListener('mouseleave', () => {
  viewState.panning = false;
  canvas.classList.remove('panning');
  viewState.hoverCell = null;
  viewState.dirtyRender = true;
  requestRender();
});

canvas.addEventListener('click', e => {
  if (viewState.didPan) {
    viewState.didPan = false;
    return;
  }
  if (e.ctrlKey) return;

  const rect = canvas.getBoundingClientRect();
  const [cx, cy] = screenToCell(e.clientX - rect.left, e.clientY - rect.top);
  reveal(cx, cy);
});

canvas.addEventListener('contextmenu', e => {
  e.preventDefault();
  if (viewState.didPan) return;

  const rect = canvas.getBoundingClientRect();
  const [cx, cy] = screenToCell(e.clientX - rect.left, e.clientY - rect.top);
  toggleFlag(cx, cy);
});

canvas.addEventListener('wheel', e => {
  e.preventDefault();

  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const factor = e.deltaY < 0 ? 1.15 : 1 / 1.15;
  const newZoom = Math.min(CONFIG.ZOOM_MAX, Math.max(CONFIG.ZOOM_MIN, viewState.zoom * factor));
  const scale = newZoom / viewState.zoom;

  viewState.offX = mx - scale * (mx - viewState.offX);
  viewState.offY = my - scale * (my - viewState.offY);
  viewState.zoom = newZoom;

  viewState.dirtyRender = true;
  requestRender();
}, { passive: false });

// Touch events
let lastTouchDist = null;
let lastTouchCx, lastTouchCy;

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  
  if (e.touches.length === 2) {
    lastTouchDist = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY
    );
    lastTouchCx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
    lastTouchCy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
  } else if (e.touches.length === 1) {
    viewState.panning = true;
    viewState.didPan = false;
    viewState.panStartX = e.touches[0].clientX;
    viewState.panStartY = e.touches[0].clientY;
    viewState.panOffX0 = viewState.offX;
    viewState.panOffY0 = viewState.offY;
    lastTouchDist = null;
  }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  
  if (e.touches.length === 2 && lastTouchDist !== null) {
    const dist = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY
    );
    const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
    const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
    
    const rect = canvas.getBoundingClientRect();
    const mx = cx - rect.left;
    const my = cy - rect.top;
    
    const newZoom = Math.min(CONFIG.ZOOM_MAX, Math.max(CONFIG.ZOOM_MIN, 
      viewState.zoom * (dist / lastTouchDist)));
    const scale = newZoom / viewState.zoom;
    
    viewState.offX = mx - scale * (mx - viewState.offX) + (cx - lastTouchCx);
    viewState.offY = my - scale * (my - viewState.offY) + (cy - lastTouchCy);
    viewState.zoom = newZoom;
    
    lastTouchDist = dist;
    lastTouchCx = cx;
    lastTouchCy = cy;
    
    viewState.dirtyRender = true;
    requestRender();
  } else if (e.touches.length === 1 && viewState.panning) {
    const dx = e.touches[0].clientX - viewState.panStartX;
    const dy = e.touches[0].clientY - viewState.panStartY;
    
    if (Math.abs(dx) > 2 || Math.abs(dy) > 2) {
      viewState.didPan = true;
    }
    
    viewState.offX = viewState.panOffX0 + dx;
    viewState.offY = viewState.panOffY0 + dy;
    viewState.dirtyRender = true;
    requestRender();
  }
}, { passive: false });

canvas.addEventListener('touchend', e => {
  e.preventDefault();
  
  if (e.changedTouches.length === 1 && !viewState.didPan && e.touches.length === 0) {
    const touch = e.changedTouches[0];
    const rect = canvas.getBoundingClientRect();
    const [cx, cy] = screenToCell(touch.clientX - rect.left, touch.clientY - rect.top);
    reveal(cx, cy);
  }
  
  viewState.panning = false;
  viewState.didPan = false;
  lastTouchDist = null;
}, { passive: false });

// Keyboard shortcuts
document.addEventListener('keydown', e => {
  if (e.ctrlKey && e.key === 'z') {
    e.preventDefault();
    undo();
  }
  if (e.ctrlKey && e.key === 'r') {
    e.preventDefault();
    newGame();
  }
  if (e.ctrlKey && e.key === 's') {
    e.preventDefault();
    saveGame();
  }
});

// Button handlers
newGameBtn.addEventListener('click', () => newGame());
undoBtn.addEventListener('click', undo);
saveBtn.addEventListener('click', saveGame);
exportBtn.addEventListener('click', exportGame);

applySeedBtn.addEventListener('click', () => {
  const seed = seedInputEl.value.trim();
  if (seed) {
    newGame(seed);
  } else {
    newGame();
  }
});

importBtn.addEventListener('click', () => {
  const code = importInputEl.value.trim();
  if (code) {
    importGame(code);
    importInputEl.value = '';
  }
});

modalUndo.addEventListener('click', () => {
  modalOverlay.classList.remove('show');
  undo();
});

modalNew.addEventListener('click', () => {
  modalOverlay.classList.remove('show');
  newGame();
});

sidebarToggle.addEventListener('click', () => {
  sidebar.classList.toggle('show');
});

// Close modal on overlay click
modalOverlay.addEventListener('click', e => {
  if (e.target === modalOverlay) {
    modalOverlay.classList.remove('show');
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AUTO-SAVE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

setInterval(() => {
  if (gameState.revealedCount > 0 && !gameState.gameOver) {
    saveGame();
  }
}, CONFIG.AUTO_SAVE_INTERVAL);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INITIALIZATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

window.addEventListener('load', () => {
  // Initialize canvas size
  const rect = canvasWrap.getBoundingClientRect();
  viewState.W = canvas.width = Math.floor(rect.width);
  viewState.H = canvas.height = Math.floor(rect.height);

  // Initialize background
  initBackground();

  // Try to load saved game, otherwise start new
  if (!loadGame()) {
    newGame();
  }

  // Show mobile sidebar toggle on small screens
  if (window.innerWidth <= 768) {
    sidebarToggle.style.display = 'flex';
  }

  window.addEventListener('resize', () => {
    bgCanvas.width = window.innerWidth;
    bgCanvas.height = window.innerHeight;
    
    if (window.innerWidth <= 768) {
      sidebarToggle.style.display = 'flex';
    } else {
      sidebarToggle.style.display = 'none';
      sidebar.classList.remove('show');
    }
  });
});

</script>
</body>
</html>
